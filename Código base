
#include <limits.h> 
#include <stdbool.h>
#include <stddef.h> 
#include <stdio.h>  
#include <stdlib.h> 
#include <string.h>  
#define array_size(a) (sizeof (a) / sizeof (*a))
#define UNUSED(x) (void)x

#define global_variable static
#define BUFFER_SIZE (8)
#define DESCRIPTION_BUFFER_SIZE (32)
#define NAME_BUFFER_SIZE (32)
#define ROUTE_BUFFER_SIZE (255)
#define DOC_PERSISTENCE_BUFFER_SIZE (512)
#define IN_CHARGE_BUFFER_SIZE (32)
#define ID_BUFFER_SIZE (11)
#define TNODE_SPACING (11)
#define INVALID_ID (0)

#define BUF_INITIALIZER {0}
#define DOC_T_INITIALIZER {0}
#define TASK_T_INITIALIZER {0}
#define PERSIST_TASK_T_INITIALIZER {0}
#define DESC_T_INITIALIZER {0}
#define ROUTE_T_INITIALIZER {0}
#define INCHARGE_T_INITIALIZER {0}
#define RESOURCE_T_INITIALIZER {0}

#define TASKS_PERSISTENCE_FILE "tasks.txt"
#define RESOURCES_PERSISTENCE_FILE "resources.txt"
#define EDGES_PERSISTENCE_FILE "edges.txt"

/*****************************************************************************/
/* type declarations */
/*****************************************************************************/
typedef void (*action_t) (void);

typedef struct
{
  char *msg;
  action_t action;
} menu_item_t;

typedef struct
{
  char data[DESCRIPTION_BUFFER_SIZE];
} desc_t;

typedef desc_t name_t;

typedef struct
{
  char data[ROUTE_BUFFER_SIZE];
} route_t;

typedef struct
{
  char data[IN_CHARGE_BUFFER_SIZE];
} incharge_t;

typedef int doc_type_t;

typedef struct
{
  int id;
  route_t route;
  desc_t description;
  doc_type_t type;
} doc_t;

typedef struct tnode tnode_t;
struct tnode
{
  doc_t doc;
  tnode_t *l;
  tnode_t *r;
};

typedef enum
{
  OPERATIVE,
  APPROVAL,
  CONTRACT,
  MANAGEMENT,
  CHANGE,
  INVALID_TASK
} task_type_t;

typedef struct
{
  int id;
  desc_t description;
  task_type_t type;
  int effort;
  int time;
  incharge_t in_charge;
  tnode_t docs;
} task_t;

typedef struct
{
  int id;
  desc_t description;
  task_type_t type;
  int effort;
  int time;
  incharge_t in_charge;
  doc_t doc;
} persist_task_t;

typedef task_type_t res_type_t;

typedef struct
{
  int id;
  name_t name;
  res_type_t type;
  int capacity;
  int available_amount;
  incharge_t in_charge;
} resource_t;

typedef struct task_node task_node_t;

struct task_node
{
  task_t task;
  task_node_t *prev;
  task_node_t *next;
};

typedef struct
{
  task_node_t *head;
  task_node_t *tail;
  size_t size;
} task_list_t;

typedef struct res_node res_node_t;

struct res_node
{
  resource_t resource;
  res_node_t *prev;
  res_node_t *next;
};

typedef struct
{
  res_node_t *head;
  res_node_t *tail;
} res_list_t;

/* structure to hold adjacency information */
typedef struct
{
  int src;
  int dst;
  int cost;
} edge_t;

typedef struct edge_node edge_node_t;
struct edge_node
{
  edge_t edge;
  edge_node_t* prev;
  edge_node_t* next;
};

typedef struct
{
  edge_node_t* head;
  edge_node_t* tail;
} edge_list_t;

typedef struct
{
  int* parents;
  int* shortest_distances;
  int count; 
} dijkstra_solution_t;

/*****************************************************************************/
/* function declarations */
/*****************************************************************************/

bool in_edge_list (edge_t* e, edge_list_t* list);
persist_task_t from_task (task_t* t);
void load_task_docs (task_t* t);
task_t from_persist_task (persist_task_t* t);
void load_persistent_data (void);
void store_task_docs (int task_id, tnode_t* t, FILE* task_docs_file);
void persist_task_docs (task_t* t);
void persist_data (void);
void print_tnode (tnode_t* n);
void print_doc (doc_t* d);
void clear_docs_aux (tnode_t* t);
void clear_docs (tnode_t* root);
void clear_task_list (task_list_t* list);
void clear_res_list (res_list_t* list);
void clear_edge_list (edge_list_t* list);
void clear_lists (void);
void task_list_push (task_list_t* list, task_t t);
bool has_been_visited (task_t const* const t, task_list_t* queue);
void res_list_push (res_list_t* list, resource_t r);
void edge_list_push (edge_list_t* list, edge_t e);
void meta_print_task (task_t *t, char *header, char *indent);
void print_resource (resource_t* r);
void print_edge (edge_t* e);
void interactive_task_edge_route_print (void);
void interactive_task_mst_print (void);
void print_task (task_t *t);
void update_task_docs_aux (tnode_t* t, int type);
void update_task_docs (task_t* t);
void print_docs_details (tnode_t* t);
void test_populate_list (task_list_t* list);
void print_last_task (task_t *t);
incharge_t prompt_task_incharge (void);
task_node_t* get_task_node (task_t* t, task_list_t* list);
task_t* get_task_ref (task_list_t* list);
doc_t input_doc (task_t* task_ref);
void show_docs (tnode_t* t);
void input_task_doc (task_t* t, doc_t* d);
void interactive_document_input (void);
void interactive_document_list (void);
void meta_menu (menu_item_t *items, int items_len, bool *loop_close_cond);
void interactive_task_input (void);
void main_quit (void);
char * task_type_str (task_type_t type);
void meta_prompt (menu_item_t *items, int items_len);
void input_task_quit (void);
task_t prompt_task_input (void);
void interactive_task_list (void);
void interactive_task_edit (void);
void print_list (task_list_t* list);
int prompt_input_int (void);
task_t prompt_task_data (void);
void meta_interactive_task_input (void);
route_t prompt_input_route (void);
desc_t prompt_input_desc (char const *msg_template);
name_t prompt_input_name (char const *msg_template);
void print_docs (tnode_t* t, int space);
void interactive_document_edit (void);
void remove_bst_node (tnode_t* mainroot, tnode_t* root, int id);
void interactive_document_remove (void);
tnode_t* find_document (int id, tnode_t* root);
tnode_t* find_biggest (tnode_t* root);
tnode_t* find_parent (tnode_t* root, tnode_t* node);
tnode_t* find_parent_from_id (tnode_t* root, int id);
doc_t prompt_doc_data (void);
void interactive_resource_input (void);
void interactive_resource_remove (void);
void interactive_resource_list (void);
void interactive_edge_list (void);
void interactive_edge_input (void);

/*****************************************************************************/
/* global variable declarations */
/*****************************************************************************/

static bool main_close = false;
static bool task_input_close = false;

static menu_item_t main_items[] =
{
  {
    .msg = "Input a task",
    .action = interactive_task_input
  },
  {
    .msg = "Edit a task",
    .action = interactive_task_edit
  },
  {
    .msg = "Show all tasks",
    .action = interactive_task_list
  },
  {
    .msg = "Input a document",
    .action = interactive_document_input
  },
  {
    .msg = "Edit a document",
    .action = interactive_document_edit
  },
  {
    .msg = "Remove a document",
    .action = interactive_document_remove
  },
  {
    .msg = "Show all documents",
    .action = interactive_document_list
  },
  {
    .msg = "Input a resource",
    .action = interactive_resource_input
  },
  {
    .msg = "Remove a resource",
    .action = interactive_resource_remove
  },
  {
    .msg = "Show all resources",
    .action = interactive_resource_list
  },
  {
    .msg = "Input task edge",
    .action = interactive_edge_input
  },
  {
    .msg = "Show task edges",
    .action = interactive_edge_list
  },
  {
    .msg = "Show recommended task route",
    .action = interactive_task_edge_route_print
  },
  {
    .msg = "Show MST",
    .action = interactive_task_mst_print
  },
  {
    .msg = "Quit",
    .action = main_quit
  }
};
static int main_items_len = array_size (main_items);

global_variable task_list_t tasks = {
  .head = NULL,
  .tail = NULL,
  .size = 0
};

global_variable res_list_t resources = {
  .head = NULL,
  .tail = NULL
};

global_variable edge_list_t edges = {
  .head = NULL,
  .tail = NULL
};

/*****************************************************************************/
/* function body definitions */
/*****************************************************************************/

// check whether an edge has been inserted
bool in_edge_list (edge_t* e, edge_list_t* list)
{
  bool result = false;
  {
    edge_node_t *it = list->head;
    while (it != NULL)
    {
      if (it->edge.src == e->src && it->edge.dst == e->dst)
      {
        result = true;
        break;
      }
      it = it->next;
    }
  }
  return result;
}

//convert task representation 
persist_task_t from_task (task_t* t)
{
  persist_task_t result = PERSIST_TASK_T_INITIALIZER;
  {
    result.id          = t->id;
    result.description = t->description;
    result.type        = t->type;
    result.effort      = t->effort;
    result.time        = t->time;
    result.in_charge   = t->in_charge;
    result.doc         = t->docs.doc;
  }
  return result;
}

//function to load a task's documents
void load_task_docs (task_t* t)
{
  int doc_id = t->docs.doc.id;
  if (doc_id == INVALID_ID)
  {
    return;
  }
  {
    char task_doc_buf[DOC_PERSISTENCE_BUFFER_SIZE] = BUF_INITIALIZER;
    char task_filename_template[] = "task_%d.txt";
    size_t bufsz = sizeof(task_doc_buf);
    snprintf (task_doc_buf, bufsz, task_filename_template, t->id);
    FILE* outer_f = fopen (task_doc_buf, "r");
    if (outer_f != NULL)
    {
      int tmpid;
      size_t bytes_read_outer = fread (&tmpid, sizeof(tmpid), 1, outer_f);
      while (bytes_read_outer > 0 && !feof (outer_f))
      {
        char doc_buf[DOC_PERSISTENCE_BUFFER_SIZE] = BUF_INITIALIZER;
        char doc_filename_template[] = "task%ddoc%d.txt";
        size_t bufsz = sizeof(doc_buf);
        snprintf (doc_buf, bufsz, doc_filename_template, t->id, tmpid);
        FILE* inner_f = fopen (doc_buf, "r");
        if (inner_f != NULL)
        {
          doc_t load_node;
          size_t bytes_read = fread (&load_node, sizeof(load_node), 1, inner_f);
          while (bytes_read > 0 && !feof (inner_f))
          {
            input_task_doc (t, &load_node);
            bytes_read = fread (&load_node, sizeof(load_node), 1, inner_f);
          }
          fclose (inner_f);
        }
        bytes_read_outer = fread (&tmpid, sizeof(tmpid), 1, outer_f);
      }
      fclose (outer_f);
    }
  }
}

//function to convert task representation for runtime

task_t from_persist_task (persist_task_t* t)
{
  task_t result = TASK_T_INITIALIZER;
  {
    result.id          = t->id;
    result.description = t->description;
    result.type        = t->type;
    result.effort      = t->effort;
    result.time        = t->time;
    result.in_charge   = t->in_charge;
    result.docs.doc    = t->doc;
    result.docs.l      = NULL;
    result.docs.r      = NULL;
  }
  return result;
}

//loads data if present to file

void load_persistent_data (void)
{
  {
    task_list_t* list = &tasks;
    char* file_name = TASKS_PERSISTENCE_FILE;
    FILE *f = fopen (file_name, "r");
    if (f != NULL)
    {
      persist_task_t t;
      size_t bytes_read = fread (&t, sizeof (t), 1, f);
      while (bytes_read > 0 && !feof (f))
      {
        task_t mem_task = from_persist_task (&t);
        load_task_docs (&mem_task);
        task_list_push (list, mem_task);
        bytes_read = fread (&t, sizeof (t), 1, f);
      }
      fclose (f);
    }
  }
  {
    res_list_t* list = &resources;
    char* file_name = RESOURCES_PERSISTENCE_FILE;
    FILE *f = fopen (file_name, "r");
    if (f != NULL)
    {
      resource_t r;
      size_t bytes_read = fread (&r, sizeof (r), 1, f);
      while (bytes_read > 0 && !feof (f))
      {
        res_list_push (list, r);
        bytes_read = fread (&r, sizeof (r), 1, f);
      }
      fclose (f);
    }
  }
  {
    edge_list_t* list = &edges;
    char* file_name = EDGES_PERSISTENCE_FILE;
    FILE *f = fopen (file_name, "r");
    if (f != NULL)
    {
      edge_t e;
      size_t bytes_read = fread (&e, sizeof (e), 1, f);
      while (bytes_read > 0 && !feof (f))
      {
        edge_list_push (list, e);
        bytes_read = fread (&e, sizeof (e), 1, f);
      }
      fclose (f);
    }
  }
}

/* description: auxiliary function to save a task's documents to persistent
 * storage, performs BST preorder traversal (root, then left subtree, then
 * right subtree), so subsequent loading inserts documents in the same order as
 * inserted by user
 * params:
 * @param task_id: id of the task to save documents of
 * @param t: pointer to task's document BST
 * @param task_docs_file: pointer to C stream where to write doc is
 * output: N/A
 * restrictions: will exit early if pointer to BST is NULL
 * restrictions: C stream must be open for writing
 */
void store_task_docs (int task_id, tnode_t* t, FILE* task_docs_file)
{
  if (t == NULL)
  {
    return;
  }
  int doc_id = t->doc.id;
  fwrite (&doc_id, sizeof (doc_id), 1, task_docs_file);
  char task_doc_name_buf[DOC_PERSISTENCE_BUFFER_SIZE] = BUF_INITIALIZER;
  char doc_filename_template[] = "task%ddoc%d.txt";
  size_t bufsz = sizeof(task_doc_name_buf);
  snprintf (task_doc_name_buf, bufsz, doc_filename_template, task_id, doc_id);
  FILE* f = fopen (task_doc_name_buf, "w");
  if (f != NULL)
  {
    fwrite (&t->doc, sizeof (t->doc), 1, f);
    fclose (f);
  }
  store_task_docs (task_id, t->l, task_docs_file);
  store_task_docs (task_id, t->r, task_docs_file);
}

/* description: function to save a task's document to persistent storage, the
 * tree traversal is done in preorder (root, then left subtree, then right
 * subtree), so that subsequent loading gets documents in the same order
 * params:
 * @param task_id: id of the task to save documents of
 * @param t: pointer to task's document BST
 * @param task_docs_file: pointer to C stream where to write doc is
 * output: N/A
 * restrictions: will exit early if pointer to BST is NULL,
 * C stream must be open for writing
 */
void persist_task_docs (task_t* t)
{
  int doc_id = t->docs.doc.id;
  if (doc_id == INVALID_ID)
  {
    return;
  }
  char task_docs_buf[DOC_PERSISTENCE_BUFFER_SIZE] = BUF_INITIALIZER;
  char* doc_filename_template = "task_%d.txt";
  size_t bufsz = sizeof (task_docs_buf);
  snprintf (task_docs_buf, bufsz, doc_filename_template, t->id);
  FILE* f = fopen (task_docs_buf, "w");
  if (f != NULL)
  {
    tnode_t* node = &t->docs;
    /* NOTE: omit the parent node because it's not needed here */
    store_task_docs (t->id, node->l, f);
    store_task_docs (t->id, node->r, f);
    fclose (f);
  }
}

//persist data

void persist_data (void)
{
  {
    task_list_t* list = &tasks;
    char* file_name = TASKS_PERSISTENCE_FILE;
    FILE *f = fopen (file_name, "w");
    if (f != NULL)
    {
      task_node_t *head = list->head;
      task_node_t *it = head;
      while (it != NULL)
      {
        task_t* mem_task = &it->task;
        persist_task_t t = from_task (mem_task);;
        fwrite (&t, sizeof (t), 1, f);
        persist_task_docs (mem_task);
        it = it->next;
      }
      fclose (f);
    }
  }
  {
    res_list_t* list = &resources;
    char* file_name = RESOURCES_PERSISTENCE_FILE;
    FILE *f = fopen (file_name, "w");
    if (f != NULL)
    {
      res_node_t *head = list->head;
      res_node_t *it = head;
      while (it != NULL)
      {
        resource_t* r = &it->resource;
        fwrite (r, sizeof (*r), 1, f);
        it = it->next;
      }
      fclose (f);
    }
  }
  {
    edge_list_t* list = &edges;
    char* file_name = EDGES_PERSISTENCE_FILE;
    FILE *f = fopen (file_name, "w");
    if (f != NULL)
    {
      edge_node_t *head = list->head;
      edge_node_t *it = head;
      while (it != NULL)
      {
        edge_t* e = &it->edge;
        fwrite (e, sizeof (*e), 1, f);
        it = it->next;
      }
      fclose (f);
    }
  }
}

//auxiliary function to print a BST node's data
void print_tnode (tnode_t* n)
{
  if (n == NULL)
  {
    return;
  }
  char const* header = " ";
  char const* indent = " ";
  printf ("%snode:\n", header);
  printf ("%sl: %s\n", indent, n->l ? "Y" : "NULL");
  printf ("%sr: %s \n", indent, n->r ? "Y" : "NULL");
  print_doc (&n->doc);
}

//to print a doc_t struct's data
void print_doc (doc_t* d)
{
  if (d == NULL)
  {
    return;
  }
  char const* header = " ";
  char const* indent = " ";
  printf ("%sDOC:\n", header);
  printf ("%sid: %d\n", indent, d->id);
  printf ("%sroute: \"%s\"\n", indent, d->route.data);
  printf ("%sdescription: \"%s\"\n", indent, d->description.data);
  printf ("%stype: %s\n", indent, task_type_str (d->type));
}

//auxiliary function to clear heap memory from BST
void clear_docs_aux (tnode_t* t)
{
  if (t == NULL)
  {
    return;
  }
  tnode_t* r = t->r;
  tnode_t* l = t->l;
  free (t);
  clear_docs_aux (r);
  clear_docs_aux (l);
}

//clears heap memory from BST
void clear_docs (tnode_t* root)
{
  clear_docs_aux (root->r);
  clear_docs_aux (root->l);
}

// auxiliary functions to free heap-allocated memory in the list
void clear_task_list (task_list_t* list)
{
  if (list == NULL)
  {
    return;
  }
  task_node_t *head = list->head;
  task_node_t *it = head;
  task_node_t *tmp;
  while (it != NULL)
  {
    tmp = it->next;
    clear_docs (&it->task.docs);
    free (it);
    it = tmp;
  }
  list->head = NULL;
  list->tail = NULL;
}

void
clear_res_list (res_list_t* list)
{
  if (list == NULL)
  {
    return;
  }
  res_node_t *head = list->head;
  res_node_t *it = head;
  res_node_t *tmp;
  while (it != NULL)
  {
    tmp = it->next;
    free (it);
    it = tmp;
  }
  list->head = NULL;
  list->tail = NULL;
}

void clear_edge_list (edge_list_t* list)
{
  if (list == NULL)
  {
    return;
  }
  edge_node_t *head = list->head;
  edge_node_t *it = head;
  edge_node_t *tmp;
  while (it != NULL)
  {
    tmp = it->next;
    free (it);
    it = tmp;
  }
  list->head = NULL;
  list->tail = NULL;
}

void clear_lists (void)
{
  clear_task_list (&tasks);
  clear_res_list (&resources);
  clear_edge_list (&edges);
}


//inserts a task in the list of tasks
void task_list_push (task_list_t* list, task_t t)
{
  if (list == NULL)
  {
    fprintf (stderr, "ERROR: invalid list\n");
    return;
  }
  task_node_t *new = (task_node_t *)malloc (sizeof (*new));
  list->size++;
  new->task = t;
  new->next = NULL;
  new->prev = NULL;
  if (list->tail == NULL)
  {
    list->head = new;
    list->tail = new;
  }
  else
  {
    list->tail->next = new;
    new->prev = list->tail;
    list->tail = new;
  }
}

// function to validate if the task has been visited
bool has_been_visited (task_t const* const t, task_list_t* list)
{
  bool result = false;
  {
    task_node_t* it = list->head;
    while (it != NULL)
    {
      if (t == &it->task)
      {
        result = true;
        break;
      }
      it = it->next;
    }
  }
  return result;
}

//inserts a resource in the list of resources
void res_list_push (res_list_t* list, resource_t r)
{
  if (list == NULL)
  {
    fprintf (stderr, "ERROR: invalid list\n");
    return;
  }
  res_node_t *new = (res_node_t *)malloc (sizeof (*new));
  new->resource = r;
  new->next = NULL;
  new->prev = NULL;
  if (list->tail == NULL)
  {
    list->head = new;
    list->tail = new;
  }
  else
  {
    list->tail->next = new;
    new->prev = list->tail;
    list->tail = new;
  }
}

//inserts an edge in the list of edges

void edge_list_push (edge_list_t* list, edge_t e)
{
  if (list == NULL)
  {
    fprintf (stderr, "ERROR: invalid list\n");
    return;
  }
  if (in_edge_list (&e, list))
  {
    printf ("Edge already exists\n");
    return;
  }
  edge_node_t *new = (edge_node_t *)malloc (sizeof (*new));
  new->edge = e;
  new->next = NULL;
  new->prev = NULL;
  if (list->tail == NULL)
  {
    list->head = new;
    list->tail = new;
  }
  else
  {
    list->tail->next = new;
    new->prev = list->tail;
    list->tail = new;
  }
}

//function to print a task's data
void meta_print_task (task_t *t, char *header, char *indent)
{
  printf ("TASK:\n");
  printf ("%sid: %d\n", indent, t->id);
  printf ("%sdescription: \"%s\"\n", indent, t->description.data);
  printf ("%stype: %s\n", indent, task_type_str (t->type));
  printf ("%seffort: %d\n", indent, t->effort);
  printf ("%stime: %d\n", indent, t->time);
  printf ("%sin charge: \"%s\"\n", indent, t->in_charge.data);
}

//function to print a resources's data
void print_resource (resource_t* r)
{
  printf ("Resource:\n");
  printf ("id: %d\n", r->id);
  printf ("name: \"%s\"\n", r->name.data);
  printf ("type: %s\n", task_type_str (r->type));
  printf ("capacity: %d\n", r->capacity);
  printf ("available amount: %d\n", r->available_amount);
  printf ("in charge: \"%s\"\n", r->in_charge.data);
}

//function to print an edge's data

void print_edge (edge_t* e)
{
  printf ("(%d) --|%d|-->(%d)\n", e->src, e->cost, e->dst);
}

/* description: function to print a task's data, using '*' and '|' has header
 * and indent respectively, for printing task
 * params:
 * @param t: pointer to task_t structure pointing to task to print
 * output: N/A, prints to stdout
 * restrictions: will exit early if pointer to task is NULL
 */
void print_task (task_t *t)
{
  if (t == NULL)
  {
    return;
  }
  meta_print_task (t, " ", " ");
}

//auxiliary function to fill an integer array with a number

 void fill_with_number (int* arr, int n, size_t count)
{
  for (size_t i = 0; i < count; ++i)
  {
    arr[i] = n;
  }
}

//auxiliary function to print 1 of all shortest paths
 void print_path (int current_vertex, int* parents, int limit, int* ids_array)
{
  if (current_vertex == -1)
  {
    return;
  }
  int next_vertex = parents[current_vertex];
  print_path (next_vertex, parents, limit, ids_array);
  printf (" -> %d", ids_array[current_vertex]);
}

//auxiliary function to print shortest paths
void print_paths (int start_vertex, dijkstra_solution_t *s, int* ids_array)
{
	int nVertices = s->count;
  printf ("Vertex\t\tDistance\tPath");
	for (int vertex_index = 0; vertex_index < nVertices; vertex_index++)
  {
		if (vertex_index != start_vertex)
    {
      printf ("\n%d -> ", ids_array[start_vertex]);
      printf ("%d\t\t", ids_array[vertex_index]);
      printf ("%d\t\t", s->shortest_distances[vertex_index]);
			print_path (vertex_index, s->parents, s->count, ids_array);
		}
	}
  printf ("\n");
}

/* description: function to calculate shortest distances in adjacency matrix
 * this relates to section 3.5, the shortest task route via dijkstra
 * params:
 * @param adjacency: pointer to 2D array in 1D space of adjacency
 * weights
 * @param start_vertex: initial task's ID index
 * @param s: auxiliary structure to store algorithm's data
 * output: N/A
 * restrictions: pointer argument must be valid
 */
void dijkstra (int* adjacency, int start_vertex, dijkstra_solution_t* s)
{
  int num_vertices = s->count;
  int* added       = (int*)malloc (s->count * sizeof(*added));
  for (int i = 0; i < num_vertices; ++i)
  {
    s->shortest_distances[i] = INT_MAX >> 1;
    added[i] = 0;
  }
  s->shortest_distances[start_vertex] = 0;
  s->parents[start_vertex] = -1;
  for (int i = 1; i < num_vertices; ++i)
  {
    int nearest_vertex = -1;
    int shortest_distance = INT_MAX >> 1;
    for (int vi = 0; vi < num_vertices; ++vi)
    {
      if (!added[vi] && s->shortest_distances[vi] < shortest_distance)
      {
        nearest_vertex = vi;
        shortest_distance = s->shortest_distances[vi];
      }
    }
    added[nearest_vertex] = 1;
    for (int vi = 0; vi < num_vertices; ++vi)
    {
      int edge_distance = adjacency[num_vertices*nearest_vertex + vi];
      if ((edge_distance > 0) && ((shortest_distance + edge_distance) < s->shortest_distances[vi]))
      {
        s->parents[vi] = nearest_vertex;
        s->shortest_distances[vi] = shortest_distance + edge_distance;
      }
    }
  }
  free (added);
}

// auxiliary function that get index of array where an ID is stored
int index_from_id (int id, int* ids_array, int side)
{
  int result = -1;
  for (int i = 0; i < side; ++i)
  {
    if (ids_array[i] == id)
    {
      result = i;
      break;
    }
  }
  return result;
}

/* description: function to print task route through edges
 * this relates to section 3.5, the shortest task route
 * params:
 * @param task_id: ID of initial task in route
 * output: N/A, prints to stdout
 * restrictions: will exit early if pointer to task is NULL
 */
void interactive_task_edge_route_print (void)
{
  if (edges.head == NULL)
  {
    printf ("\nNo edges yet\n\n");
    return;
  }
  task_list_t* list = &tasks;
  print_list (list);
  printf ("please input initial task ID, ");
  task_t* initial = get_task_ref (list);
  {
    int side = 0;
    for (task_node_t* t = tasks.head; t != NULL; t = t->next)
    {
      side++;
    }
    int size = side * side;
    int* adj_array = (int*)malloc (size * sizeof (*adj_array));
    int* ids_array = (int*)malloc (side * sizeof (*ids_array));
    fill_with_number (adj_array, INT_MAX >> 1, size);
    {
      int i = 0;
      for (task_node_t* t = tasks.head; t != NULL; t = t->next, i++)
      {
        ids_array[i] = t->task.id;
      }
      for (int i = 0; i < side; ++i)
      {
        for (int j = 0; j < side; ++j)
        {
          for (edge_node_t* en = edges.head; en != NULL; en = en->next)
          {
            if (
                ((ids_array[i] == en->edge.src) && (ids_array[j] == en->edge.dst))
             || ((ids_array[j] == en->edge.src) && (ids_array[i] == en->edge.dst))
            )
            {
              adj_array[i*side + j] = en->edge.cost;
              break;
            }
          }
        }
      }
      for (int i = 0; i < side; ++i)
      {
        adj_array[i*side + i] = 0;
      }
      dijkstra_solution_t s = {
        .parents            = (int*)malloc (side * sizeof(*s.parents)),
        .shortest_distances = (int*)malloc (side * sizeof(*s.shortest_distances)),
        .count = side
      };
      int index = index_from_id (initial->id, ids_array, side);
      dijkstra (adj_array, index, &s);
      print_paths (index, &s, ids_array);
      free (s.parents);
      free (s.shortest_distances);
    }
    free (ids_array);
    free (adj_array);
  }
}

//auxiliary function to find the index of the lowest element in mst_set array
int min_key (int* costs, int* mst_set, int side)
{
  int min = INT_MAX;
  int min_index;
  for (int i = 0; i < side; i++)
  {
    if (mst_set[i] == 0 && costs[i] < min)
    {
      min = costs[i];
      min_index = i;
    }
  }
  return min_index;
}

//auxiliary function to print minimal spanning tree

void print_mst (int* parents, int* adj_array, int side, int* ids_array)
{
  printf ("Source\tDestination\tWeight\n");
  for (int i = 1; i < side; i++)
  {
    printf ("%d\t%d\t\t%d\n",
      ids_array[parents[i]], ids_array[i], adj_array[i*side + parents[i]]
    );
  }
}

//function to print task graph minimum spanning tree

void interactive_task_mst_print (void)
{
  if (edges.head == NULL)
  {
    printf ("\nNo edges yet\n\n");
    return;
  }
  int side = 0;
  for (task_node_t* t = tasks.head; t != NULL; t = t->next)
  {
    side++;
  }
  int size = side * side;
  int* adj_array = (int*)malloc (size * sizeof(*adj_array));
  int* parents = (int*)malloc (side * sizeof(*parents));
  int* costs = (int*)malloc (side * sizeof(*costs));
  int* mst_set = (int*)malloc (side * sizeof(*mst_set));
  int* ids_array = (int*)malloc (side * sizeof (*ids_array));
  for (int i = 0; i < side; ++i)
  {
    costs[i] = INT_MAX;
    mst_set[i] = 0;
    parents[i] = 0;
  }
  int i = 0;
  for (task_node_t* t = tasks.head; t != NULL; t = t->next, i++)
  {
    ids_array[i] = t->task.id;
  }
  for (int i = 0; i < side; ++i)
  {
    for (int j = 0; j < side; ++j)
    {
      for (edge_node_t* en = edges.head; en != NULL; en = en->next)
      {
        if (
            ((ids_array[i] == en->edge.src) && (ids_array[j] == en->edge.dst))
          || ((ids_array[j] == en->edge.src) && (ids_array[i] == en->edge.dst))
        )
        {
          adj_array[i*side + j] = en->edge.cost;
          break;
        }
      }
    }
  }
  costs[0] = 0;
  parents[0] = -1;
  for (int i = 0; i < side - 1; ++i)
  {
    int u = min_key (costs, mst_set, side);
    mst_set[u] = 1;
    for (int v = 0; v < side; ++v)
    {
      if (adj_array[u*side + v] && mst_set[v] == 0 && adj_array[u*side + v] < costs[v])
      {
        parents[v] = u;
        costs[v] = adj_array[u*side + v];
      }
    }
  }
  print_mst (parents, adj_array, side, ids_array);
  free (mst_set);
  free (costs);
  free (parents);
  free (adj_array);
}

//auxiliary function to update type of document in a task
void update_task_docs_aux (tnode_t* t, int type)
{
  if (t == NULL)
  {
    return;
  }
  t->doc.type = type;
  tnode_t* r = t->r;
  tnode_t* l = t->l;
  update_task_docs_aux (r, type);
  update_task_docs_aux (l, type);
}

//function to update type of every document in a task
void update_task_docs (task_t* t)
{
  if (t == NULL)
  {
    return;
  }
  update_task_docs_aux (&t->docs, t->type);
}

//function to print all documents in a BST

void print_docs_details (tnode_t* t)
{
  if (t == NULL)
  {
    return;
  }
  print_docs_details (t->r);
  print_doc (&t->doc);
  printf ("\n");
  print_docs_details (t->l);
}

//function to fill list with tasks

void test_populate_list (task_list_t* list)
{
  for (int i = 0; i < 0x4; ++i)
  {
    task_t t = {
      .id = i,
      .description = { "" },
      .type = INVALID_TASK - 1 - i,
      .effort = 2,
      .time = 35,
      .in_charge = { "" }
    };
    task_list_push (list, t);
  }
}

void print_last_task (task_t *t)
{
  meta_print_task (t, "", "  ");
}

//function to input a person in charge

incharge_t prompt_task_incharge (void)
{
  incharge_t result = INCHARGE_T_INITIALIZER;
  char const *msg_template
      = "Person in charge (must be under %lu characters): ";
  char person_buffer[sizeof (result) + 1] = BUF_INITIALIZER;
  printf (msg_template, sizeof (result));
  bool loop_cond = true;
  while (loop_cond && fgets (person_buffer, sizeof (person_buffer), stdin))
  {
    char *newline = strchr (person_buffer, '\n');
    if (newline == NULL)
    {
      for (int c = getchar (); c != EOF && c != '\n'; c = getchar ())
        ;
      printf (msg_template, sizeof (result));
      memset (person_buffer, 0, sizeof (person_buffer));
    }
    else
    {
      int len = newline - person_buffer;
      memcpy (result.data, person_buffer, len);
      loop_cond = false;
    }
  } 
  return result;
}

// function to get a task node from a valid task ID

task_node_t*
get_task_node (task_t* t, task_list_t* list)
{
  task_node_t* result = NULL;
  {
    task_node_t* it = list->head;
    while (it != NULL)
    {
      if (&it->task == t)
      {
        break;
      }
      it = it->next;
    }
    result = it;
  }
  return result;
}

// function to get a pointer to a task in a list

task_t* get_task_ref (task_list_t* list)
{
  task_t* result = NULL;
  {
    task_node_t *it = list->head;
    bool valid_id = false;
    int id = INVALID_ID;
    while (!valid_id)
    {
      while (id == INVALID_ID)
      {
        id = prompt_input_int ();
        if (id == INVALID_ID)
        {
          printf ("task IDs must be positive integers\nplease input a valid task ID\n");
        }
      }
      {
        task_node_t *head = NULL;
        head = list->head;
        it = head;
        while (it != NULL)
        {
          if (id == it->task.id)
          {
            valid_id = true;
            result = &it->task;
            break;
          }
          it = it->next;
        }
        if (!valid_id)
        {
          printf ("\nplease input a valid task ID\n");
          id = INVALID_ID;
        }
      }
    }
  }
  return result;
}
