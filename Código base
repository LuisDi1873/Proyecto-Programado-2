
#include <limits.h> 
#include <stdbool.h>
#include <stddef.h> 
#include <stdio.h>  
#include <stdlib.h> 
#include <string.h>  
#define array_size(a) (sizeof (a) / sizeof (*a))
#define UNUSED(x) (void)x

#define global_variable static
#define BUFFER_SIZE (8)
#define DESCRIPTION_BUFFER_SIZE (32)
#define NAME_BUFFER_SIZE (32)
#define ROUTE_BUFFER_SIZE (255)
#define DOC_PERSISTENCE_BUFFER_SIZE (512)
#define IN_CHARGE_BUFFER_SIZE (32)
#define ID_BUFFER_SIZE (11)
#define TNODE_SPACING (11)
#define INVALID_ID (0)

#define BUF_INITIALIZER {0}
#define DOC_T_INITIALIZER {0}
#define TASK_T_INITIALIZER {0}
#define PERSIST_TASK_T_INITIALIZER {0}
#define DESC_T_INITIALIZER {0}
#define ROUTE_T_INITIALIZER {0}
#define INCHARGE_T_INITIALIZER {0}
#define RESOURCE_T_INITIALIZER {0}

#define TASKS_PERSISTENCE_FILE "tasks.txt"
#define RESOURCES_PERSISTENCE_FILE "resources.txt"
#define EDGES_PERSISTENCE_FILE "edges.txt"

/*****************************************************************************/
/* type declarations */
/*****************************************************************************/
typedef void (*action_t) (void);

typedef struct
{
  char *msg;
  action_t action;
} menu_item_t;

typedef struct
{
  char data[DESCRIPTION_BUFFER_SIZE];
} desc_t;

typedef desc_t name_t;

typedef struct
{
  char data[ROUTE_BUFFER_SIZE];
} route_t;

typedef struct
{
  char data[IN_CHARGE_BUFFER_SIZE];
} incharge_t;

typedef int doc_type_t;

typedef struct
{
  int id;
  route_t route;
  desc_t description;
  doc_type_t type;
} doc_t;

typedef struct tnode tnode_t;
struct tnode
{
  doc_t doc;
  tnode_t *l;
  tnode_t *r;
};

typedef enum
{
  OPERATIVE,
  APPROVAL,
  CONTRACT,
  MANAGEMENT,
  CHANGE,
  INVALID_TASK
} task_type_t;

typedef struct
{
  int id;
  desc_t description;
  task_type_t type;
  int effort;
  int time;
  incharge_t in_charge;
  tnode_t docs;
} task_t;

typedef struct
{
  int id;
  desc_t description;
  task_type_t type;
  int effort;
  int time;
  incharge_t in_charge;
  doc_t doc;
} persist_task_t;

typedef task_type_t res_type_t;

typedef struct
{
  int id;
  name_t name;
  res_type_t type;
  int capacity;
  int available_amount;
  incharge_t in_charge;
} resource_t;

typedef struct task_node task_node_t;

struct task_node
{
  task_t task;
  task_node_t *prev;
  task_node_t *next;
};

typedef struct
{
  task_node_t *head;
  task_node_t *tail;
  size_t size;
} task_list_t;

typedef struct res_node res_node_t;

struct res_node
{
  resource_t resource;
  res_node_t *prev;
  res_node_t *next;
};

typedef struct
{
  res_node_t *head;
  res_node_t *tail;
} res_list_t;

/* structure to hold adjacency information */
typedef struct
{
  int src;
  int dst;
  int cost;
} edge_t;

typedef struct edge_node edge_node_t;
struct edge_node
{
  edge_t edge;
  edge_node_t* prev;
  edge_node_t* next;
};

typedef struct
{
  edge_node_t* head;
  edge_node_t* tail;
} edge_list_t;

typedef struct
{
  int* parents;
  int* shortest_distances;
  int count; 
} dijkstra_solution_t;

/*****************************************************************************/
/* function declarations */
/*****************************************************************************/

bool in_edge_list (edge_t* e, edge_list_t* list);
persist_task_t from_task (task_t* t);
void load_task_docs (task_t* t);
task_t from_persist_task (persist_task_t* t);
void load_persistent_data (void);
void store_task_docs (int task_id, tnode_t* t, FILE* task_docs_file);
void persist_task_docs (task_t* t);
void persist_data (void);
void print_tnode (tnode_t* n);
void print_doc (doc_t* d);
void clear_docs_aux (tnode_t* t);
void clear_docs (tnode_t* root);
void clear_task_list (task_list_t* list);
void clear_res_list (res_list_t* list);
void clear_edge_list (edge_list_t* list);
void clear_lists (void);
void task_list_push (task_list_t* list, task_t t);
bool has_been_visited (task_t const* const t, task_list_t* queue);
void res_list_push (res_list_t* list, resource_t r);
void edge_list_push (edge_list_t* list, edge_t e);
void meta_print_task (task_t *t, char *header, char *indent);
void print_resource (resource_t* r);
void print_edge (edge_t* e);
void interactive_task_edge_route_print (void);
void interactive_task_mst_print (void);
void print_task (task_t *t);
void update_task_docs_aux (tnode_t* t, int type);
void update_task_docs (task_t* t);
void print_docs_details (tnode_t* t);
void test_populate_list (task_list_t* list);
void print_last_task (task_t *t);
incharge_t prompt_task_incharge (void);
task_node_t* get_task_node (task_t* t, task_list_t* list);
task_t* get_task_ref (task_list_t* list);
doc_t input_doc (task_t* task_ref);
void show_docs (tnode_t* t);
void input_task_doc (task_t* t, doc_t* d);
void interactive_document_input (void);
void interactive_document_list (void);
void meta_menu (menu_item_t *items, int items_len, bool *loop_close_cond);
void interactive_task_input (void);
void main_quit (void);
char * task_type_str (task_type_t type);
void meta_prompt (menu_item_t *items, int items_len);
void input_task_quit (void);
task_t prompt_task_input (void);
void interactive_task_list (void);
void interactive_task_edit (void);
void print_list (task_list_t* list);
int prompt_input_int (void);
task_t prompt_task_data (void);
void meta_interactive_task_input (void);
route_t prompt_input_route (void);
desc_t prompt_input_desc (char const *msg_template);
name_t prompt_input_name (char const *msg_template);
void print_docs (tnode_t* t, int space);
void interactive_document_edit (void);
void remove_bst_node (tnode_t* mainroot, tnode_t* root, int id);
void interactive_document_remove (void);
tnode_t* find_document (int id, tnode_t* root);
tnode_t* find_biggest (tnode_t* root);
tnode_t* find_parent (tnode_t* root, tnode_t* node);
tnode_t* find_parent_from_id (tnode_t* root, int id);
doc_t prompt_doc_data (void);
void interactive_resource_input (void);
void interactive_resource_remove (void);
void interactive_resource_list (void);
void interactive_edge_list (void);
void interactive_edge_input (void);
