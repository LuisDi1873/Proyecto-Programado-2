
#include <limits.h> 
#include <stdbool.h>
#include <stddef.h> 
#include <stdio.h>  
#include <stdlib.h> 
#include <string.h>  
#define array_size(a) (sizeof (a) / sizeof (*a))
#define UNUSED(x) (void)x

#define global_variable static
#define BUFFER_SIZE (8)
#define DESCRIPTION_BUFFER_SIZE (32)
#define NAME_BUFFER_SIZE (32)
#define ROUTE_BUFFER_SIZE (255)
#define DOC_PERSISTENCE_BUFFER_SIZE (512)
#define IN_CHARGE_BUFFER_SIZE (32)
#define ID_BUFFER_SIZE (11)
#define TNODE_SPACING (11)
#define INVALID_ID (0)

#define BUF_INITIALIZER {0}
#define DOC_T_INITIALIZER {0}
#define TASK_T_INITIALIZER {0}
#define PERSIST_TASK_T_INITIALIZER {0}
#define DESC_T_INITIALIZER {0}
#define ROUTE_T_INITIALIZER {0}
#define INCHARGE_T_INITIALIZER {0}
#define RESOURCE_T_INITIALIZER {0}

#define TASKS_PERSISTENCE_FILE "tasks.txt"
#define RESOURCES_PERSISTENCE_FILE "resources.txt"
#define EDGES_PERSISTENCE_FILE "edges.txt"

/*****************************************************************************/
/* type declarations */
/*****************************************************************************/
typedef void (*action_t) (void);

typedef struct
{
  char *msg;
  action_t action;
} menu_item_t;

typedef struct
{
  char data[DESCRIPTION_BUFFER_SIZE];
} desc_t;

typedef desc_t name_t;

typedef struct
{
  char data[ROUTE_BUFFER_SIZE];
} route_t;

typedef struct
{
  char data[IN_CHARGE_BUFFER_SIZE];
} incharge_t;

typedef int doc_type_t;

typedef struct
{
  int id;
  route_t route;
  desc_t description;
  doc_type_t type;
} doc_t;

typedef struct tnode tnode_t;
struct tnode
{
  doc_t doc;
  tnode_t *l;
  tnode_t *r;
};

typedef enum
{
  OPERATIVE,
  APPROVAL,
  CONTRACT,
  MANAGEMENT,
  CHANGE,
  INVALID_TASK
} task_type_t;

typedef struct
{
  int id;
  desc_t description;
  task_type_t type;
  int effort;
  int time;
  incharge_t in_charge;
  tnode_t docs;
} task_t;

typedef struct
{
  int id;
  desc_t description;
  task_type_t type;
  int effort;
  int time;
  incharge_t in_charge;
  doc_t doc;
} persist_task_t;

typedef task_type_t res_type_t;

typedef struct
{
  int id;
  name_t name;
  res_type_t type;
  int capacity;
  int available_amount;
  incharge_t in_charge;
} resource_t;

typedef struct task_node task_node_t;

struct task_node
{
  task_t task;
  task_node_t *prev;
  task_node_t *next;
};

typedef struct
{
  task_node_t *head;
  task_node_t *tail;
  size_t size;
} task_list_t;

typedef struct res_node res_node_t;

struct res_node
{
  resource_t resource;
  res_node_t *prev;
  res_node_t *next;
};

typedef struct
{
  res_node_t *head;
  res_node_t *tail;
} res_list_t;

/* structure to hold adjacency information */
typedef struct
{
  int src;
  int dst;
  int cost;
} edge_t;

typedef struct edge_node edge_node_t;
struct edge_node
{
  edge_t edge;
  edge_node_t* prev;
  edge_node_t* next;
};

typedef struct
{
  edge_node_t* head;
  edge_node_t* tail;
} edge_list_t;

typedef struct
{
  int* parents;
  int* shortest_distances;
  int count; 
} dijkstra_solution_t;

/*****************************************************************************/
/* function declarations */
/*****************************************************************************/

bool in_edge_list (edge_t* e, edge_list_t* list);
persist_task_t from_task (task_t* t);
void load_task_docs (task_t* t);
task_t from_persist_task (persist_task_t* t);
void load_persistent_data (void);
void store_task_docs (int task_id, tnode_t* t, FILE* task_docs_file);
void persist_task_docs (task_t* t);
void persist_data (void);
void print_tnode (tnode_t* n);
void print_doc (doc_t* d);
void clear_docs_aux (tnode_t* t);
void clear_docs (tnode_t* root);
void clear_task_list (task_list_t* list);
void clear_res_list (res_list_t* list);
void clear_edge_list (edge_list_t* list);
void clear_lists (void);
void task_list_push (task_list_t* list, task_t t);
bool has_been_visited (task_t const* const t, task_list_t* queue);
void res_list_push (res_list_t* list, resource_t r);
void edge_list_push (edge_list_t* list, edge_t e);
void meta_print_task (task_t *t, char *header, char *indent);
void print_resource (resource_t* r);
void print_edge (edge_t* e);
void interactive_task_edge_route_print (void);
void interactive_task_mst_print (void);
void print_task (task_t *t);
void update_task_docs_aux (tnode_t* t, int type);
void update_task_docs (task_t* t);
void print_docs_details (tnode_t* t);
void test_populate_list (task_list_t* list);
void print_last_task (task_t *t);
incharge_t prompt_task_incharge (void);
task_node_t* get_task_node (task_t* t, task_list_t* list);
task_t* get_task_ref (task_list_t* list);
doc_t input_doc (task_t* task_ref);
void show_docs (tnode_t* t);
void input_task_doc (task_t* t, doc_t* d);
void interactive_document_input (void);
void interactive_document_list (void);
void meta_menu (menu_item_t *items, int items_len, bool *loop_close_cond);
void interactive_task_input (void);
void main_quit (void);
char * task_type_str (task_type_t type);
void meta_prompt (menu_item_t *items, int items_len);
void input_task_quit (void);
task_t prompt_task_input (void);
void interactive_task_list (void);
void interactive_task_edit (void);
void print_list (task_list_t* list);
int prompt_input_int (void);
task_t prompt_task_data (void);
void meta_interactive_task_input (void);
route_t prompt_input_route (void);
desc_t prompt_input_desc (char const *msg_template);
name_t prompt_input_name (char const *msg_template);
void print_docs (tnode_t* t, int space);
void interactive_document_edit (void);
void remove_bst_node (tnode_t* mainroot, tnode_t* root, int id);
void interactive_document_remove (void);
tnode_t* find_document (int id, tnode_t* root);
tnode_t* find_biggest (tnode_t* root);
tnode_t* find_parent (tnode_t* root, tnode_t* node);
tnode_t* find_parent_from_id (tnode_t* root, int id);
doc_t prompt_doc_data (void);
void interactive_resource_input (void);
void interactive_resource_remove (void);
void interactive_resource_list (void);
void interactive_edge_list (void);
void interactive_edge_input (void);

/*****************************************************************************/
/* global variable declarations */
/*****************************************************************************/

static bool main_close = false;
static bool task_input_close = false;

static menu_item_t main_items[] =
{
  {
    .msg = "Input a task",
    .action = interactive_task_input
  },
  {
    .msg = "Edit a task",
    .action = interactive_task_edit
  },
  {
    .msg = "Show all tasks",
    .action = interactive_task_list
  },
  {
    .msg = "Input a document",
    .action = interactive_document_input
  },
  {
    .msg = "Edit a document",
    .action = interactive_document_edit
  },
  {
    .msg = "Remove a document",
    .action = interactive_document_remove
  },
  {
    .msg = "Show all documents",
    .action = interactive_document_list
  },
  {
    .msg = "Input a resource",
    .action = interactive_resource_input
  },
  {
    .msg = "Remove a resource",
    .action = interactive_resource_remove
  },
  {
    .msg = "Show all resources",
    .action = interactive_resource_list
  },
  {
    .msg = "Input task edge",
    .action = interactive_edge_input
  },
  {
    .msg = "Show task edges",
    .action = interactive_edge_list
  },
  {
    .msg = "Show recommended task route",
    .action = interactive_task_edge_route_print
  },
  {
    .msg = "Show MST",
    .action = interactive_task_mst_print
  },
  {
    .msg = "Quit",
    .action = main_quit
  }
};
static int main_items_len = array_size (main_items);

global_variable task_list_t tasks = {
  .head = NULL,
  .tail = NULL,
  .size = 0
};

global_variable res_list_t resources = {
  .head = NULL,
  .tail = NULL
};

global_variable edge_list_t edges = {
  .head = NULL,
  .tail = NULL
};

/*****************************************************************************/
/* function body definitions */
/*****************************************************************************/

// check whether an edge has been inserted
bool in_edge_list (edge_t* e, edge_list_t* list)
{
  bool result = false;
  {
    edge_node_t *it = list->head;
    while (it != NULL)
    {
      if (it->edge.src == e->src && it->edge.dst == e->dst)
      {
        result = true;
        break;
      }
      it = it->next;
    }
  }
  return result;
}

//convert task representation 
persist_task_t from_task (task_t* t)
{
  persist_task_t result = PERSIST_TASK_T_INITIALIZER;
  {
    result.id          = t->id;
    result.description = t->description;
    result.type        = t->type;
    result.effort      = t->effort;
    result.time        = t->time;
    result.in_charge   = t->in_charge;
    result.doc         = t->docs.doc;
  }
  return result;
}

//function to load a task's documents
void load_task_docs (task_t* t)
{
  int doc_id = t->docs.doc.id;
  if (doc_id == INVALID_ID)
  {
    return;
  }
  {
    char task_doc_buf[DOC_PERSISTENCE_BUFFER_SIZE] = BUF_INITIALIZER;
    char task_filename_template[] = "task_%d.txt";
    size_t bufsz = sizeof(task_doc_buf);
    snprintf (task_doc_buf, bufsz, task_filename_template, t->id);
    FILE* outer_f = fopen (task_doc_buf, "r");
    if (outer_f != NULL)
    {
      int tmpid;
      size_t bytes_read_outer = fread (&tmpid, sizeof(tmpid), 1, outer_f);
      while (bytes_read_outer > 0 && !feof (outer_f))
      {
        char doc_buf[DOC_PERSISTENCE_BUFFER_SIZE] = BUF_INITIALIZER;
        char doc_filename_template[] = "task%ddoc%d.txt";
        size_t bufsz = sizeof(doc_buf);
        snprintf (doc_buf, bufsz, doc_filename_template, t->id, tmpid);
        FILE* inner_f = fopen (doc_buf, "r");
        if (inner_f != NULL)
        {
          doc_t load_node;
          size_t bytes_read = fread (&load_node, sizeof(load_node), 1, inner_f);
          while (bytes_read > 0 && !feof (inner_f))
          {
            input_task_doc (t, &load_node);
            bytes_read = fread (&load_node, sizeof(load_node), 1, inner_f);
          }
          fclose (inner_f);
        }
        bytes_read_outer = fread (&tmpid, sizeof(tmpid), 1, outer_f);
      }
      fclose (outer_f);
    }
  }
}

//function to convert task representation for runtime

task_t from_persist_task (persist_task_t* t)
{
  task_t result = TASK_T_INITIALIZER;
  {
    result.id          = t->id;
    result.description = t->description;
    result.type        = t->type;
    result.effort      = t->effort;
    result.time        = t->time;
    result.in_charge   = t->in_charge;
    result.docs.doc    = t->doc;
    result.docs.l      = NULL;
    result.docs.r      = NULL;
  }
  return result;
}

//loads data if present to file

void load_persistent_data (void)
{
  {
    task_list_t* list = &tasks;
    char* file_name = TASKS_PERSISTENCE_FILE;
    FILE *f = fopen (file_name, "r");
    if (f != NULL)
    {
      persist_task_t t;
      size_t bytes_read = fread (&t, sizeof (t), 1, f);
      while (bytes_read > 0 && !feof (f))
      {
        task_t mem_task = from_persist_task (&t);
        load_task_docs (&mem_task);
        task_list_push (list, mem_task);
        bytes_read = fread (&t, sizeof (t), 1, f);
      }
      fclose (f);
    }
  }
  {
    res_list_t* list = &resources;
    char* file_name = RESOURCES_PERSISTENCE_FILE;
    FILE *f = fopen (file_name, "r");
    if (f != NULL)
    {
      resource_t r;
      size_t bytes_read = fread (&r, sizeof (r), 1, f);
      while (bytes_read > 0 && !feof (f))
      {
        res_list_push (list, r);
        bytes_read = fread (&r, sizeof (r), 1, f);
      }
      fclose (f);
    }
  }
  {
    edge_list_t* list = &edges;
    char* file_name = EDGES_PERSISTENCE_FILE;
    FILE *f = fopen (file_name, "r");
    if (f != NULL)
    {
      edge_t e;
      size_t bytes_read = fread (&e, sizeof (e), 1, f);
      while (bytes_read > 0 && !feof (f))
      {
        edge_list_push (list, e);
        bytes_read = fread (&e, sizeof (e), 1, f);
      }
      fclose (f);
    }
  }
}
