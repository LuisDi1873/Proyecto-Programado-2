
#include <limits.h> 
#include <stdbool.h>
#include <stddef.h> 
#include <stdio.h>  
#include <stdlib.h> 
#include <string.h>  
#define array_size(a) (sizeof (a) / sizeof (*a))
#define UNUSED(x) (void)x

#define global_variable static
#define BUFFER_SIZE (8)
#define DESCRIPTION_BUFFER_SIZE (32)
#define NAME_BUFFER_SIZE (32)
#define ROUTE_BUFFER_SIZE (255)
#define DOC_PERSISTENCE_BUFFER_SIZE (512)
#define IN_CHARGE_BUFFER_SIZE (32)
#define ID_BUFFER_SIZE (11)
#define TNODE_SPACING (11)
#define INVALID_ID (0)

#define BUF_INITIALIZER {0}
#define DOC_T_INITIALIZER {0}
#define TASK_T_INITIALIZER {0}
#define PERSIST_TASK_T_INITIALIZER {0}
#define DESC_T_INITIALIZER {0}
#define ROUTE_T_INITIALIZER {0}
#define INCHARGE_T_INITIALIZER {0}
#define RESOURCE_T_INITIALIZER {0}

#define TASKS_PERSISTENCE_FILE "tasks.txt"
#define RESOURCES_PERSISTENCE_FILE "resources.txt"
#define EDGES_PERSISTENCE_FILE "edges.txt"

/*****************************************************************************/
/* type declarations */
/*****************************************************************************/
typedef void (*action_t) (void);

typedef struct
{
  char *msg;
  action_t action;
} menu_item_t;

typedef struct
{
  char data[DESCRIPTION_BUFFER_SIZE];
} desc_t;

typedef desc_t name_t;

typedef struct
{
  char data[ROUTE_BUFFER_SIZE];
} route_t;

typedef struct
{
  char data[IN_CHARGE_BUFFER_SIZE];
} incharge_t;

typedef int doc_type_t;

typedef struct
{
  int id;
  route_t route;
  desc_t description;
  doc_type_t type;
} doc_t;

typedef struct tnode tnode_t;
struct tnode
{
  doc_t doc;
  tnode_t *l;
  tnode_t *r;
};

typedef enum
{
  OPERATIVE,
  APPROVAL,
  CONTRACT,
  MANAGEMENT,
  CHANGE,
  INVALID_TASK
} task_type_t;

typedef struct
{
  int id;
  desc_t description;
  task_type_t type;
  int effort;
  int time;
  incharge_t in_charge;
  tnode_t docs;
} task_t;

typedef struct
{
  int id;
  desc_t description;
  task_type_t type;
  int effort;
  int time;
  incharge_t in_charge;
  doc_t doc;
} persist_task_t;

typedef task_type_t res_type_t;

typedef struct
{
  int id;
  name_t name;
  res_type_t type;
  int capacity;
  int available_amount;
  incharge_t in_charge;
} resource_t;

typedef struct task_node task_node_t;

struct task_node
{
  task_t task;
  task_node_t *prev;
  task_node_t *next;
};

typedef struct
{
  task_node_t *head;
  task_node_t *tail;
  size_t size;
} task_list_t;

typedef struct res_node res_node_t;

struct res_node
{
  resource_t resource;
  res_node_t *prev;
  res_node_t *next;
};

typedef struct
{
  res_node_t *head;
  res_node_t *tail;
} res_list_t;

/* structure to hold adjacency information */
typedef struct
{
  int src;
  int dst;
  int cost;
} edge_t;

typedef struct edge_node edge_node_t;
struct edge_node
{
  edge_t edge;
  edge_node_t* prev;
  edge_node_t* next;
};

typedef struct
{
  edge_node_t* head;
  edge_node_t* tail;
} edge_list_t;

typedef struct
{
  int* parents;
  int* shortest_distances;
  int count; 
} dijkstra_solution_t;

/*****************************************************************************/
/* function declarations */
/*****************************************************************************/

bool in_edge_list (edge_t* e, edge_list_t* list);
persist_task_t from_task (task_t* t);
void load_task_docs (task_t* t);
task_t from_persist_task (persist_task_t* t);
void load_persistent_data (void);
void store_task_docs (int task_id, tnode_t* t, FILE* task_docs_file);
void persist_task_docs (task_t* t);
void persist_data (void);
void print_tnode (tnode_t* n);
void print_doc (doc_t* d);
void clear_docs_aux (tnode_t* t);
void clear_docs (tnode_t* root);
void clear_task_list (task_list_t* list);
void clear_res_list (res_list_t* list);
void clear_edge_list (edge_list_t* list);
void clear_lists (void);
void task_list_push (task_list_t* list, task_t t);
bool has_been_visited (task_t const* const t, task_list_t* queue);
void res_list_push (res_list_t* list, resource_t r);
void edge_list_push (edge_list_t* list, edge_t e);
void meta_print_task (task_t *t, char *header, char *indent);
void print_resource (resource_t* r);
void print_edge (edge_t* e);
void interactive_task_edge_route_print (void);
void interactive_task_mst_print (void);
void print_task (task_t *t);
void update_task_docs_aux (tnode_t* t, int type);
void update_task_docs (task_t* t);
void print_docs_details (tnode_t* t);
void test_populate_list (task_list_t* list);
void print_last_task (task_t *t);
incharge_t prompt_task_incharge (void);
task_node_t* get_task_node (task_t* t, task_list_t* list);
task_t* get_task_ref (task_list_t* list);
doc_t input_doc (task_t* task_ref);
void show_docs (tnode_t* t);
void input_task_doc (task_t* t, doc_t* d);
void interactive_document_input (void);
void interactive_document_list (void);
void meta_menu (menu_item_t *items, int items_len, bool *loop_close_cond);
void interactive_task_input (void);
void main_quit (void);
char * task_type_str (task_type_t type);
void meta_prompt (menu_item_t *items, int items_len);
void input_task_quit (void);
task_t prompt_task_input (void);
void interactive_task_list (void);
void interactive_task_edit (void);
void print_list (task_list_t* list);
int prompt_input_int (void);
task_t prompt_task_data (void);
void meta_interactive_task_input (void);
route_t prompt_input_route (void);
desc_t prompt_input_desc (char const *msg_template);
name_t prompt_input_name (char const *msg_template);
void print_docs (tnode_t* t, int space);
void interactive_document_edit (void);
void remove_bst_node (tnode_t* mainroot, tnode_t* root, int id);
void interactive_document_remove (void);
tnode_t* find_document (int id, tnode_t* root);
tnode_t* find_biggest (tnode_t* root);
tnode_t* find_parent (tnode_t* root, tnode_t* node);
tnode_t* find_parent_from_id (tnode_t* root, int id);
doc_t prompt_doc_data (void);
void interactive_resource_input (void);
void interactive_resource_remove (void);
void interactive_resource_list (void);
void interactive_edge_list (void);
void interactive_edge_input (void);

/*****************************************************************************/
/* global variable declarations */
/*****************************************************************************/

static bool main_close = false;
static bool task_input_close = false;

static menu_item_t main_items[] =
{
  {
    .msg = "Input a task",
    .action = interactive_task_input
  },
  {
    .msg = "Edit a task",
    .action = interactive_task_edit
  },
  {
    .msg = "Show all tasks",
    .action = interactive_task_list
  },
  {
    .msg = "Input a document",
    .action = interactive_document_input
  },
  {
    .msg = "Edit a document",
    .action = interactive_document_edit
  },
  {
    .msg = "Remove a document",
    .action = interactive_document_remove
  },
  {
    .msg = "Show all documents",
    .action = interactive_document_list
  },
  {
    .msg = "Input a resource",
    .action = interactive_resource_input
  },
  {
    .msg = "Remove a resource",
    .action = interactive_resource_remove
  },
  {
    .msg = "Show all resources",
    .action = interactive_resource_list
  },
  {
    .msg = "Input task edge",
    .action = interactive_edge_input
  },
  {
    .msg = "Show task edges",
    .action = interactive_edge_list
  },
  {
    .msg = "Show recommended task route",
    .action = interactive_task_edge_route_print
  },
  {
    .msg = "Show MST",
    .action = interactive_task_mst_print
  },
  {
    .msg = "Quit",
    .action = main_quit
  }
};
static int main_items_len = array_size (main_items);

global_variable task_list_t tasks = {
  .head = NULL,
  .tail = NULL,
  .size = 0
};

global_variable res_list_t resources = {
  .head = NULL,
  .tail = NULL
};

global_variable edge_list_t edges = {
  .head = NULL,
  .tail = NULL
};

/*****************************************************************************/
/* function body definitions */
/*****************************************************************************/

// check whether an edge has been inserted
bool in_edge_list (edge_t* e, edge_list_t* list)
{
  bool result = false;
  {
    edge_node_t *it = list->head;
    while (it != NULL)
    {
      if (it->edge.src == e->src && it->edge.dst == e->dst)
      {
        result = true;
        break;
      }
      it = it->next;
    }
  }
  return result;
}

//convert task representation 
persist_task_t from_task (task_t* t)
{
  persist_task_t result = PERSIST_TASK_T_INITIALIZER;
  {
    result.id          = t->id;
    result.description = t->description;
    result.type        = t->type;
    result.effort      = t->effort;
    result.time        = t->time;
    result.in_charge   = t->in_charge;
    result.doc         = t->docs.doc;
  }
  return result;
}

//function to load a task's documents
void load_task_docs (task_t* t)
{
  int doc_id = t->docs.doc.id;
  if (doc_id == INVALID_ID)
  {
    return;
  }
  {
    char task_doc_buf[DOC_PERSISTENCE_BUFFER_SIZE] = BUF_INITIALIZER;
    char task_filename_template[] = "task_%d.txt";
    size_t bufsz = sizeof(task_doc_buf);
    snprintf (task_doc_buf, bufsz, task_filename_template, t->id);
    FILE* outer_f = fopen (task_doc_buf, "r");
    if (outer_f != NULL)
    {
      int tmpid;
      size_t bytes_read_outer = fread (&tmpid, sizeof(tmpid), 1, outer_f);
      while (bytes_read_outer > 0 && !feof (outer_f))
      {
        char doc_buf[DOC_PERSISTENCE_BUFFER_SIZE] = BUF_INITIALIZER;
        char doc_filename_template[] = "task%ddoc%d.txt";
        size_t bufsz = sizeof(doc_buf);
        snprintf (doc_buf, bufsz, doc_filename_template, t->id, tmpid);
        FILE* inner_f = fopen (doc_buf, "r");
        if (inner_f != NULL)
        {
          doc_t load_node;
          size_t bytes_read = fread (&load_node, sizeof(load_node), 1, inner_f);
          while (bytes_read > 0 && !feof (inner_f))
          {
            input_task_doc (t, &load_node);
            bytes_read = fread (&load_node, sizeof(load_node), 1, inner_f);
          }
          fclose (inner_f);
        }
        bytes_read_outer = fread (&tmpid, sizeof(tmpid), 1, outer_f);
      }
      fclose (outer_f);
    }
  }
}

//function to convert task representation for runtime

task_t from_persist_task (persist_task_t* t)
{
  task_t result = TASK_T_INITIALIZER;
  {
    result.id          = t->id;
    result.description = t->description;
    result.type        = t->type;
    result.effort      = t->effort;
    result.time        = t->time;
    result.in_charge   = t->in_charge;
    result.docs.doc    = t->doc;
    result.docs.l      = NULL;
    result.docs.r      = NULL;
  }
  return result;
}

//loads data if present to file

void load_persistent_data (void)
{
  {
    task_list_t* list = &tasks;
    char* file_name = TASKS_PERSISTENCE_FILE;
    FILE *f = fopen (file_name, "r");
    if (f != NULL)
    {
      persist_task_t t;
      size_t bytes_read = fread (&t, sizeof (t), 1, f);
      while (bytes_read > 0 && !feof (f))
      {
        task_t mem_task = from_persist_task (&t);
        load_task_docs (&mem_task);
        task_list_push (list, mem_task);
        bytes_read = fread (&t, sizeof (t), 1, f);
      }
      fclose (f);
    }
  }
  {
    res_list_t* list = &resources;
    char* file_name = RESOURCES_PERSISTENCE_FILE;
    FILE *f = fopen (file_name, "r");
    if (f != NULL)
    {
      resource_t r;
      size_t bytes_read = fread (&r, sizeof (r), 1, f);
      while (bytes_read > 0 && !feof (f))
      {
        res_list_push (list, r);
        bytes_read = fread (&r, sizeof (r), 1, f);
      }
      fclose (f);
    }
  }
  {
    edge_list_t* list = &edges;
    char* file_name = EDGES_PERSISTENCE_FILE;
    FILE *f = fopen (file_name, "r");
    if (f != NULL)
    {
      edge_t e;
      size_t bytes_read = fread (&e, sizeof (e), 1, f);
      while (bytes_read > 0 && !feof (f))
      {
        edge_list_push (list, e);
        bytes_read = fread (&e, sizeof (e), 1, f);
      }
      fclose (f);
    }
  }
}

/* description: auxiliary function to save a task's documents to persistent
 * storage, performs BST preorder traversal (root, then left subtree, then
 * right subtree), so subsequent loading inserts documents in the same order as
 * inserted by user
 * params:
 * @param task_id: id of the task to save documents of
 * @param t: pointer to task's document BST
 * @param task_docs_file: pointer to C stream where to write doc is
 * output: N/A
 * restrictions: will exit early if pointer to BST is NULL
 * restrictions: C stream must be open for writing
 */
void store_task_docs (int task_id, tnode_t* t, FILE* task_docs_file)
{
  if (t == NULL)
  {
    return;
  }
  int doc_id = t->doc.id;
  fwrite (&doc_id, sizeof (doc_id), 1, task_docs_file);
  char task_doc_name_buf[DOC_PERSISTENCE_BUFFER_SIZE] = BUF_INITIALIZER;
  char doc_filename_template[] = "task%ddoc%d.txt";
  size_t bufsz = sizeof(task_doc_name_buf);
  snprintf (task_doc_name_buf, bufsz, doc_filename_template, task_id, doc_id);
  FILE* f = fopen (task_doc_name_buf, "w");
  if (f != NULL)
  {
    fwrite (&t->doc, sizeof (t->doc), 1, f);
    fclose (f);
  }
  store_task_docs (task_id, t->l, task_docs_file);
  store_task_docs (task_id, t->r, task_docs_file);
}

/* description: function to save a task's document to persistent storage, the
 * tree traversal is done in preorder (root, then left subtree, then right
 * subtree), so that subsequent loading gets documents in the same order
 * params:
 * @param task_id: id of the task to save documents of
 * @param t: pointer to task's document BST
 * @param task_docs_file: pointer to C stream where to write doc is
 * output: N/A
 * restrictions: will exit early if pointer to BST is NULL,
 * C stream must be open for writing
 */
void persist_task_docs (task_t* t)
{
  int doc_id = t->docs.doc.id;
  if (doc_id == INVALID_ID)
  {
    return;
  }
  char task_docs_buf[DOC_PERSISTENCE_BUFFER_SIZE] = BUF_INITIALIZER;
  char* doc_filename_template = "task_%d.txt";
  size_t bufsz = sizeof (task_docs_buf);
  snprintf (task_docs_buf, bufsz, doc_filename_template, t->id);
  FILE* f = fopen (task_docs_buf, "w");
  if (f != NULL)
  {
    tnode_t* node = &t->docs;
    /* NOTE: omit the parent node because it's not needed here */
    store_task_docs (t->id, node->l, f);
    store_task_docs (t->id, node->r, f);
    fclose (f);
  }
}

//persist data

void persist_data (void)
{
  {
    task_list_t* list = &tasks;
    char* file_name = TASKS_PERSISTENCE_FILE;
    FILE *f = fopen (file_name, "w");
    if (f != NULL)
    {
      task_node_t *head = list->head;
      task_node_t *it = head;
      while (it != NULL)
      {
        task_t* mem_task = &it->task;
        persist_task_t t = from_task (mem_task);;
        fwrite (&t, sizeof (t), 1, f);
        persist_task_docs (mem_task);
        it = it->next;
      }
      fclose (f);
    }
  }
  {
    res_list_t* list = &resources;
    char* file_name = RESOURCES_PERSISTENCE_FILE;
    FILE *f = fopen (file_name, "w");
    if (f != NULL)
    {
      res_node_t *head = list->head;
      res_node_t *it = head;
      while (it != NULL)
      {
        resource_t* r = &it->resource;
        fwrite (r, sizeof (*r), 1, f);
        it = it->next;
      }
      fclose (f);
    }
  }
  {
    edge_list_t* list = &edges;
    char* file_name = EDGES_PERSISTENCE_FILE;
    FILE *f = fopen (file_name, "w");
    if (f != NULL)
    {
      edge_node_t *head = list->head;
      edge_node_t *it = head;
      while (it != NULL)
      {
        edge_t* e = &it->edge;
        fwrite (e, sizeof (*e), 1, f);
        it = it->next;
      }
      fclose (f);
    }
  }
}

//auxiliary function to print a BST node's data
void print_tnode (tnode_t* n)
{
  if (n == NULL)
  {
    return;
  }
  char const* header = " ";
  char const* indent = " ";
  printf ("%snode:\n", header);
  printf ("%sl: %s\n", indent, n->l ? "Y" : "NULL");
  printf ("%sr: %s \n", indent, n->r ? "Y" : "NULL");
  print_doc (&n->doc);
}

//to print a doc_t struct's data
void print_doc (doc_t* d)
{
  if (d == NULL)
  {
    return;
  }
  char const* header = " ";
  char const* indent = " ";
  printf ("%sDOC:\n", header);
  printf ("%sid: %d\n", indent, d->id);
  printf ("%sroute: \"%s\"\n", indent, d->route.data);
  printf ("%sdescription: \"%s\"\n", indent, d->description.data);
  printf ("%stype: %s\n", indent, task_type_str (d->type));
}

//auxiliary function to clear heap memory from BST
void clear_docs_aux (tnode_t* t)
{
  if (t == NULL)
  {
    return;
  }
  tnode_t* r = t->r;
  tnode_t* l = t->l;
  free (t);
  clear_docs_aux (r);
  clear_docs_aux (l);
}

//clears heap memory from BST
void clear_docs (tnode_t* root)
{
  clear_docs_aux (root->r);
  clear_docs_aux (root->l);
}

// auxiliary functions to free heap-allocated memory in the list
void clear_task_list (task_list_t* list)
{
  if (list == NULL)
  {
    return;
  }
  task_node_t *head = list->head;
  task_node_t *it = head;
  task_node_t *tmp;
  while (it != NULL)
  {
    tmp = it->next;
    clear_docs (&it->task.docs);
    free (it);
    it = tmp;
  }
  list->head = NULL;
  list->tail = NULL;
}

void
clear_res_list (res_list_t* list)
{
  if (list == NULL)
  {
    return;
  }
  res_node_t *head = list->head;
  res_node_t *it = head;
  res_node_t *tmp;
  while (it != NULL)
  {
    tmp = it->next;
    free (it);
    it = tmp;
  }
  list->head = NULL;
  list->tail = NULL;
}

void clear_edge_list (edge_list_t* list)
{
  if (list == NULL)
  {
    return;
  }
  edge_node_t *head = list->head;
  edge_node_t *it = head;
  edge_node_t *tmp;
  while (it != NULL)
  {
    tmp = it->next;
    free (it);
    it = tmp;
  }
  list->head = NULL;
  list->tail = NULL;
}

void clear_lists (void)
{
  clear_task_list (&tasks);
  clear_res_list (&resources);
  clear_edge_list (&edges);
}


//inserts a task in the list of tasks
void task_list_push (task_list_t* list, task_t t)
{
  if (list == NULL)
  {
    fprintf (stderr, "ERROR: invalid list\n");
    return;
  }
  task_node_t *new = (task_node_t *)malloc (sizeof (*new));
  list->size++;
  new->task = t;
  new->next = NULL;
  new->prev = NULL;
  if (list->tail == NULL)
  {
    list->head = new;
    list->tail = new;
  }
  else
  {
    list->tail->next = new;
    new->prev = list->tail;
    list->tail = new;
  }
}

// function to validate if the task has been visited
bool has_been_visited (task_t const* const t, task_list_t* list)
{
  bool result = false;
  {
    task_node_t* it = list->head;
    while (it != NULL)
    {
      if (t == &it->task)
      {
        result = true;
        break;
      }
      it = it->next;
    }
  }
  return result;
}

//inserts a resource in the list of resources
void res_list_push (res_list_t* list, resource_t r)
{
  if (list == NULL)
  {
    fprintf (stderr, "ERROR: invalid list\n");
    return;
  }
  res_node_t *new = (res_node_t *)malloc (sizeof (*new));
  new->resource = r;
  new->next = NULL;
  new->prev = NULL;
  if (list->tail == NULL)
  {
    list->head = new;
    list->tail = new;
  }
  else
  {
    list->tail->next = new;
    new->prev = list->tail;
    list->tail = new;
  }
}

//inserts an edge in the list of edges

void edge_list_push (edge_list_t* list, edge_t e)
{
  if (list == NULL)
  {
    fprintf (stderr, "ERROR: invalid list\n");
    return;
  }
  if (in_edge_list (&e, list))
  {
    printf ("Edge already exists\n");
    return;
  }
  edge_node_t *new = (edge_node_t *)malloc (sizeof (*new));
  new->edge = e;
  new->next = NULL;
  new->prev = NULL;
  if (list->tail == NULL)
  {
    list->head = new;
    list->tail = new;
  }
  else
  {
    list->tail->next = new;
    new->prev = list->tail;
    list->tail = new;
  }
}

//function to print a task's data
void meta_print_task (task_t *t, char *header, char *indent)
{
  printf ("TASK:\n");
  printf ("%sid: %d\n", indent, t->id);
  printf ("%sdescription: \"%s\"\n", indent, t->description.data);
  printf ("%stype: %s\n", indent, task_type_str (t->type));
  printf ("%seffort: %d\n", indent, t->effort);
  printf ("%stime: %d\n", indent, t->time);
  printf ("%sin charge: \"%s\"\n", indent, t->in_charge.data);
}

//function to print a resources's data
void print_resource (resource_t* r)
{
  printf ("Resource:\n");
  printf ("id: %d\n", r->id);
  printf ("name: \"%s\"\n", r->name.data);
  printf ("type: %s\n", task_type_str (r->type));
  printf ("capacity: %d\n", r->capacity);
  printf ("available amount: %d\n", r->available_amount);
  printf ("in charge: \"%s\"\n", r->in_charge.data);
}

//function to print an edge's data

void print_edge (edge_t* e)
{
  printf ("(%d) --|%d|-->(%d)\n", e->src, e->cost, e->dst);
}

/* description: function to print a task's data, using '*' and '|' has header
 * and indent respectively, for printing task
 * params:
 * @param t: pointer to task_t structure pointing to task to print
 * output: N/A, prints to stdout
 * restrictions: will exit early if pointer to task is NULL
 */
void print_task (task_t *t)
{
  if (t == NULL)
  {
    return;
  }
  meta_print_task (t, " ", " ");
}

//auxiliary function to fill an integer array with a number

 void fill_with_number (int* arr, int n, size_t count)
{
  for (size_t i = 0; i < count; ++i)
  {
    arr[i] = n;
  }
}

//auxiliary function to print 1 of all shortest paths
 void print_path (int current_vertex, int* parents, int limit, int* ids_array)
{
  if (current_vertex == -1)
  {
    return;
  }
  int next_vertex = parents[current_vertex];
  print_path (next_vertex, parents, limit, ids_array);
  printf (" -> %d", ids_array[current_vertex]);
}

//auxiliary function to print shortest paths
void print_paths (int start_vertex, dijkstra_solution_t *s, int* ids_array)
{
	int nVertices = s->count;
  printf ("Vertex\t\tDistance\tPath");
	for (int vertex_index = 0; vertex_index < nVertices; vertex_index++)
  {
		if (vertex_index != start_vertex)
    {
      printf ("\n%d -> ", ids_array[start_vertex]);
      printf ("%d\t\t", ids_array[vertex_index]);
      printf ("%d\t\t", s->shortest_distances[vertex_index]);
			print_path (vertex_index, s->parents, s->count, ids_array);
		}
	}
  printf ("\n");
}

/* description: function to calculate shortest distances in adjacency matrix
 * this relates to section 3.5, the shortest task route via dijkstra
 * params:
 * @param adjacency: pointer to 2D array in 1D space of adjacency
 * weights
 * @param start_vertex: initial task's ID index
 * @param s: auxiliary structure to store algorithm's data
 * output: N/A
 * restrictions: pointer argument must be valid
 */
void dijkstra (int* adjacency, int start_vertex, dijkstra_solution_t* s)
{
  int num_vertices = s->count;
  int* added       = (int*)malloc (s->count * sizeof(*added));
  for (int i = 0; i < num_vertices; ++i)
  {
    s->shortest_distances[i] = INT_MAX >> 1;
    added[i] = 0;
  }
  s->shortest_distances[start_vertex] = 0;
  s->parents[start_vertex] = -1;
  for (int i = 1; i < num_vertices; ++i)
  {
    int nearest_vertex = -1;
    int shortest_distance = INT_MAX >> 1;
    for (int vi = 0; vi < num_vertices; ++vi)
    {
      if (!added[vi] && s->shortest_distances[vi] < shortest_distance)
      {
        nearest_vertex = vi;
        shortest_distance = s->shortest_distances[vi];
      }
    }
    added[nearest_vertex] = 1;
    for (int vi = 0; vi < num_vertices; ++vi)
    {
      int edge_distance = adjacency[num_vertices*nearest_vertex + vi];
      if ((edge_distance > 0) && ((shortest_distance + edge_distance) < s->shortest_distances[vi]))
      {
        s->parents[vi] = nearest_vertex;
        s->shortest_distances[vi] = shortest_distance + edge_distance;
      }
    }
  }
  free (added);
}

// auxiliary function that get index of array where an ID is stored
int index_from_id (int id, int* ids_array, int side)
{
  int result = -1;
  for (int i = 0; i < side; ++i)
  {
    if (ids_array[i] == id)
    {
      result = i;
      break;
    }
  }
  return result;
}

/* description: function to print task route through edges
 * this relates to section 3.5, the shortest task route
 * params:
 * @param task_id: ID of initial task in route
 * output: N/A, prints to stdout
 * restrictions: will exit early if pointer to task is NULL
 */
void interactive_task_edge_route_print (void)
{
  if (edges.head == NULL)
  {
    printf ("\nNo edges yet\n\n");
    return;
  }
  task_list_t* list = &tasks;
  print_list (list);
  printf ("please input initial task ID, ");
  task_t* initial = get_task_ref (list);
  {
    int side = 0;
    for (task_node_t* t = tasks.head; t != NULL; t = t->next)
    {
      side++;
    }
    int size = side * side;
    int* adj_array = (int*)malloc (size * sizeof (*adj_array));
    int* ids_array = (int*)malloc (side * sizeof (*ids_array));
    fill_with_number (adj_array, INT_MAX >> 1, size);
    {
      int i = 0;
      for (task_node_t* t = tasks.head; t != NULL; t = t->next, i++)
      {
        ids_array[i] = t->task.id;
      }
      for (int i = 0; i < side; ++i)
      {
        for (int j = 0; j < side; ++j)
        {
          for (edge_node_t* en = edges.head; en != NULL; en = en->next)
          {
            if (
                ((ids_array[i] == en->edge.src) && (ids_array[j] == en->edge.dst))
             || ((ids_array[j] == en->edge.src) && (ids_array[i] == en->edge.dst))
            )
            {
              adj_array[i*side + j] = en->edge.cost;
              break;
            }
          }
        }
      }
      for (int i = 0; i < side; ++i)
      {
        adj_array[i*side + i] = 0;
      }
      dijkstra_solution_t s = {
        .parents            = (int*)malloc (side * sizeof(*s.parents)),
        .shortest_distances = (int*)malloc (side * sizeof(*s.shortest_distances)),
        .count = side
      };
      int index = index_from_id (initial->id, ids_array, side);
      dijkstra (adj_array, index, &s);
      print_paths (index, &s, ids_array);
      free (s.parents);
      free (s.shortest_distances);
    }
    free (ids_array);
    free (adj_array);
  }
}

//auxiliary function to find the index of the lowest element in mst_set array
int min_key (int* costs, int* mst_set, int side)
{
  int min = INT_MAX;
  int min_index;
  for (int i = 0; i < side; i++)
  {
    if (mst_set[i] == 0 && costs[i] < min)
    {
      min = costs[i];
      min_index = i;
    }
  }
  return min_index;
}

//auxiliary function to print minimal spanning tree

void print_mst (int* parents, int* adj_array, int side, int* ids_array)
{
  printf ("Source\tDestination\tWeight\n");
  for (int i = 1; i < side; i++)
  {
    printf ("%d\t%d\t\t%d\n",
      ids_array[parents[i]], ids_array[i], adj_array[i*side + parents[i]]
    );
  }
}

//function to print task graph minimum spanning tree

void interactive_task_mst_print (void)
{
  if (edges.head == NULL)
  {
    printf ("\nNo edges yet\n\n");
    return;
  }
  int side = 0;
  for (task_node_t* t = tasks.head; t != NULL; t = t->next)
  {
    side++;
  }
  int size = side * side;
  int* adj_array = (int*)malloc (size * sizeof(*adj_array));
  int* parents = (int*)malloc (side * sizeof(*parents));
  int* costs = (int*)malloc (side * sizeof(*costs));
  int* mst_set = (int*)malloc (side * sizeof(*mst_set));
  int* ids_array = (int*)malloc (side * sizeof (*ids_array));
  for (int i = 0; i < side; ++i)
  {
    costs[i] = INT_MAX;
    mst_set[i] = 0;
    parents[i] = 0;
  }
  int i = 0;
  for (task_node_t* t = tasks.head; t != NULL; t = t->next, i++)
  {
    ids_array[i] = t->task.id;
  }
  for (int i = 0; i < side; ++i)
  {
    for (int j = 0; j < side; ++j)
    {
      for (edge_node_t* en = edges.head; en != NULL; en = en->next)
      {
        if (
            ((ids_array[i] == en->edge.src) && (ids_array[j] == en->edge.dst))
          || ((ids_array[j] == en->edge.src) && (ids_array[i] == en->edge.dst))
        )
        {
          adj_array[i*side + j] = en->edge.cost;
          break;
        }
      }
    }
  }
  costs[0] = 0;
  parents[0] = -1;
  for (int i = 0; i < side - 1; ++i)
  {
    int u = min_key (costs, mst_set, side);
    mst_set[u] = 1;
    for (int v = 0; v < side; ++v)
    {
      if (adj_array[u*side + v] && mst_set[v] == 0 && adj_array[u*side + v] < costs[v])
      {
        parents[v] = u;
        costs[v] = adj_array[u*side + v];
      }
    }
  }
  print_mst (parents, adj_array, side, ids_array);
  free (mst_set);
  free (costs);
  free (parents);
  free (adj_array);
}

//auxiliary function to update type of document in a task
void update_task_docs_aux (tnode_t* t, int type)
{
  if (t == NULL)
  {
    return;
  }
  t->doc.type = type;
  tnode_t* r = t->r;
  tnode_t* l = t->l;
  update_task_docs_aux (r, type);
  update_task_docs_aux (l, type);
}

//function to update type of every document in a task
void update_task_docs (task_t* t)
{
  if (t == NULL)
  {
    return;
  }
  update_task_docs_aux (&t->docs, t->type);
}

//function to print all documents in a BST

void print_docs_details (tnode_t* t)
{
  if (t == NULL)
  {
    return;
  }
  print_docs_details (t->r);
  print_doc (&t->doc);
  printf ("\n");
  print_docs_details (t->l);
}

//function to fill list with tasks

void test_populate_list (task_list_t* list)
{
  for (int i = 0; i < 0x4; ++i)
  {
    task_t t = {
      .id = i,
      .description = { "" },
      .type = INVALID_TASK - 1 - i,
      .effort = 2,
      .time = 35,
      .in_charge = { "" }
    };
    task_list_push (list, t);
  }
}

void print_last_task (task_t *t)
{
  meta_print_task (t, "", "  ");
}

//function to input a person in charge

incharge_t prompt_task_incharge (void)
{
  incharge_t result = INCHARGE_T_INITIALIZER;
  char const *msg_template
      = "Person in charge (must be under %lu characters): ";
  char person_buffer[sizeof (result) + 1] = BUF_INITIALIZER;
  printf (msg_template, sizeof (result));
  bool loop_cond = true;
  while (loop_cond && fgets (person_buffer, sizeof (person_buffer), stdin))
  {
    char *newline = strchr (person_buffer, '\n');
    if (newline == NULL)
    {
      for (int c = getchar (); c != EOF && c != '\n'; c = getchar ())
        ;
      printf (msg_template, sizeof (result));
      memset (person_buffer, 0, sizeof (person_buffer));
    }
    else
    {
      int len = newline - person_buffer;
      memcpy (result.data, person_buffer, len);
      loop_cond = false;
    }
  } 
  return result;
}

// function to get a task node from a valid task ID

task_node_t*
get_task_node (task_t* t, task_list_t* list)
{
  task_node_t* result = NULL;
  {
    task_node_t* it = list->head;
    while (it != NULL)
    {
      if (&it->task == t)
      {
        break;
      }
      it = it->next;
    }
    result = it;
  }
  return result;
}

// function to get a pointer to a task in a list

task_t* get_task_ref (task_list_t* list)
{
  task_t* result = NULL;
  {
    task_node_t *it = list->head;
    bool valid_id = false;
    int id = INVALID_ID;
    while (!valid_id)
    {
      while (id == INVALID_ID)
      {
        id = prompt_input_int ();
        if (id == INVALID_ID)
        {
          printf ("task IDs must be positive integers\nplease input a valid task ID\n");
        }
      }
      {
        task_node_t *head = NULL;
        head = list->head;
        it = head;
        while (it != NULL)
        {
          if (id == it->task.id)
          {
            valid_id = true;
            result = &it->task;
            break;
          }
          it = it->next;
        }
        if (!valid_id)
        {
          printf ("\nplease input a valid task ID\n");
          id = INVALID_ID;
        }
      }
    }
  }
  return result;
}
//function to input a document's data

doc_t
input_doc (task_t* task_ref)
{
  doc_t result = DOC_T_INITIALIZER;
  {
    tnode_t* root = &task_ref->docs;
    {
      printf ("\ndocument ID ");
      int id = INVALID_ID;
      while (id == INVALID_ID)
      {
        id = prompt_input_int ();
        if (id == INVALID_ID)
        {
          printf ("task IDs must be positive integers\nplease input a valid task ID\n");
        }
      }
      doc_t* d = &root->doc;
      bool omit_search = (d->id == INVALID_ID);
      tnode_t* found = NULL;
      if (!omit_search)
      {
        found = find_document (id, root);
      }
      while (found != NULL)
      {
        printf ("\nplease input an unused document ID\n");
        while (id == INVALID_ID)
        {
          id = prompt_input_int ();
          if (id == INVALID_ID)
          {
            printf ("task IDs must be positive integers\nplease input a valid task ID\n");
          }
        }
        found = find_document (id, root);
      }
      result.id = id;
    }
    {
      doc_t d = prompt_doc_data ();
      d.id = result.id;
      result = d;
    }
    {
      result.type = task_ref->type;
    }
  }
  return result;
}

//function to print all docs in a BST

void show_docs (tnode_t* t)
{
  printf ("all docs details\n");
  print_docs_details (t);
  printf ("task document tree\n");
  print_docs (t, 0);
}

//function to input document into task

void input_task_doc (task_t* t, doc_t* new_doc)
{
  int id = new_doc->id;
  tnode_t* root = &t->docs;
  tnode_t* parent = find_parent_from_id (root, id);
  doc_t* d = &parent->doc;
  tnode_t *new = (tnode_t *)malloc (sizeof (*new));
  new->l = NULL;
  new->r = NULL;
  new->doc = *new_doc;
  if (d->id < id)
  {
    parent->r = new;
  }
  else
  {
    parent->l = new;
  }
}

//function to input a document in a task

void interactive_document_input (void)
{
  task_list_t* list = &tasks;
  if (!list->head)
  {
    printf ("\nNo tasks yet\n\n");
    return;
  }
  print_list (&tasks);
  printf ("input ID of task to add document to, ");
  task_t* task_ref = get_task_ref (list);
  {
    tnode_t* docs = &task_ref->docs;
    if (docs->doc.id != INVALID_ID)
    {
      printf ("documents in task\n");
      show_docs (&task_ref->docs);
    }
  }
  {
    doc_t new_doc = input_doc (task_ref);
    if (task_ref->docs.doc.id == INVALID_ID)
    {
      task_ref->docs.doc = new_doc;
      return;
    }
    input_task_doc (task_ref, &new_doc);
  }
}

//function to show all docs in task's document BST

void interactive_document_list (void)
{
  task_list_t* list = &tasks;
  if (!list->head)
  {
    printf ("\nNo tasks yet\n\n");
    return;
  }
  print_list (&tasks);
  printf ("input ID of task to show its documents, ");
  task_t* task_ref = get_task_ref (list);
  tnode_t* docs = &task_ref->docs;
  if (docs->doc.id == INVALID_ID)
  {
    printf ("no documents in task\n");
    return;
  }
  show_docs(docs);
}

//menu function

void meta_menu (menu_item_t *items, int items_len, bool *loop_close_cond)
{
  meta_prompt (items, items_len);
  int selection;
  bool valid_selection = false;
  while (!*loop_close_cond)
  {
    selection = prompt_input_int ();
    while (!valid_selection)
    {
      valid_selection =  ((selection >= 1) && (selection <= items_len));
      if (!valid_selection)
      {
        printf ("\ninvalid option, please input a valid option\n\n");
      }
    }
    int item_index = selection - 1;
    items[item_index].action ();
    if (!*loop_close_cond)
    {
      meta_prompt (items, items_len);
    }
  } 
  *loop_close_cond = false;
}

//function to insert a task in the list of tasks

void interactive_task_input (void)
{
  task_t t = prompt_task_input ();
  task_list_push (&tasks, t);
}

// function to close the main menu loop

void main_quit (void)
{
  main_close = true;
}

// auxiliary function to get string representation of task types
char *
task_type_str (task_type_t type)
{
  switch (type)
  {
  case OPERATIVE : return "Operative Task";
  case APPROVAL  : return "Approval Task";
  case CONTRACT  : return "Contract Signing";
  case MANAGEMENT: return "Management Task";
  case CHANGE    : return "Change";
  default        : return "INVALID TASK";
  }
}

//generic prompt function

void meta_prompt (menu_item_t *items, int items_len)
{
  printf ("\nOptions:\n");
  for (int i = 0; i < items_len; ++i)
  {
    printf ("%d: %s\n", i + 1, items[i].msg);
  }
  printf ("\nyour selection: ");
}

//function to close the task input menu loop

void input_task_quit (void)
{
  task_input_close = true;
}

// auxiliary function to input a task's data

task_t prompt_task_input (void)
{
  task_t result = TASK_T_INITIALIZER;
  printf ("please answer each space to fill task data\n");
  {
    task_list_t* list = &tasks;
    task_node_t *head;
    task_node_t *it;
    printf ("\ntask id ");
    int id = INVALID_ID;
    bool found = false;
    if (list->head == NULL)
    {
      /* list is empty */
      while (id == INVALID_ID)
      {
        id = prompt_input_int ();
        if (id == INVALID_ID)
        {
          printf ("task IDs must be positive integers\nplease input a valid task ID\n");
        }
      }
      found = true;
    }
    while (!found)
    {
      while (id == INVALID_ID)
      {
        id = prompt_input_int ();
        if (id == INVALID_ID)
        {
          printf ("task IDs must be positive integers\nplease input a valid task ID\n");
        }
      }
      head = list->head;
      it = head;
      while (it != NULL)
      {
        if (id == it->task.id)
        {
          found = true;
          break;
        }
        it = it->next;
      }
      if (!found)
      {
        found = true;
      }
      else
      {
        printf ("\nplease input an unused task ID\n");
        id = INVALID_ID;
        found = false;
      }
    } /* while (!found) */
    result.id = id;
  }
  {
    task_t partial = prompt_task_data ();
    partial.id = result.id;
    result = partial;
  }
  return result;
}

// function to print all tasks
void interactive_task_list (void)
{
  if (tasks.head == NULL)
  {
    printf ("\nNo tasks yet\n\n");
  }
  print_list (&tasks);
}

//function to edit task's data

void interactive_task_edit (void)
{
  task_list_t* list = &tasks;
  if (!list->head)
  {
    printf ("\nNo tasks yet\n\n");
    return;
  }
  print_list (&tasks);
  printf ("input ID of task to edit, ");
  task_t* task_ref = get_task_ref (list);
  printf ("\n\nNow input new task data\n");
  task_t t = prompt_task_data ();
  tnode_t tmp;
  memcpy (&tmp, &task_ref->docs, sizeof(tmp));
  int id = task_ref->id;
  *task_ref = t;
  task_ref->id = id;
  memcpy(&task_ref->docs, &tmp, sizeof(tmp));
  update_task_docs (task_ref);
}

// function to print list of tasks

void print_list (task_list_t* list)
{
  if (list == NULL)
  {
    return;
  }
  task_node_t *head = list->head;
  task_node_t *it = head;
  while (it != NULL)
  {
    if (it->next == NULL)
    {
      print_last_task (&it->task);
    }
    else
    {
      print_task (&it->task);
    }
    it = it->next;
    if (it != NULL)
    {
      printf ("|\n");
    }
  } /* while (it != NULL) */
  printf ("\n\n");
}

// function to input an integer

int prompt_input_int (void)
{
  int result = -1;
  char int_buf[ID_BUFFER_SIZE] = BUF_INITIALIZER;
  char const *msg_template = "input integer (must be under %lu digits): ";
  printf (msg_template, sizeof (int_buf));
  bool invalid_int_input = false;
  while (!invalid_int_input && fgets (int_buf, sizeof (int_buf), stdin))
  {
    char *newline = strchr (int_buf, '\n');
    if (newline == NULL)
    {
      for (int c = getchar (); c != EOF && c != '\n'; c = getchar ())
        ;
      printf (msg_template, sizeof (int_buf));
    }
    else
    {
      result = atoi (int_buf);
      invalid_int_input = (result >= 0);
    }
    if (!invalid_int_input)
    {
      printf (msg_template, sizeof (int_buf));
    }
    memset (int_buf, 0, sizeof(int_buf));
  } 
  return result;
}

//auxiliary function to input a task's data

task_t prompt_task_data (void)
{
  task_t result = TASK_T_INITIALIZER;
  {
    char const *msg_template = "Description (must be under %lu characters): ";
    desc_t d = prompt_input_desc (msg_template);
    result.description = d;
  }
  {
    printf ("\ninput task type:\n");

    for (int i = 0; i < INVALID_TASK; ++i)
    {
      int display_index = i + 1;
      printf ("%d: %s\n", display_index, task_type_str (i));
    }
    int type = INVALID_TASK;
    bool valid_type = false;
    while (!valid_type)
    {
      type = prompt_input_int ();

      valid_type = ((type > 0) && (type <= INVALID_TASK));
      if (!valid_type)
      {
        printf ("please input a valid task type\n");
      }
    }
    result.type = type - 1;
  }
  {
    printf ("Effort: ");
    int effort = prompt_input_int ();
    result.effort = effort;
  }
  {
    printf ("Time, ");
    int time = prompt_input_int ();
    result.time = time;
  }
  {
    result.in_charge = prompt_task_incharge ();
  }
  return result;
}

//function to input a file route

route_t prompt_input_route (void)
{
  route_t result = ROUTE_T_INITIALIZER;
  char route_buf[sizeof (result) + 1] = BUF_INITIALIZER;
  char const *msg_template = "route (must be under %lu characters): ";
  printf (msg_template, sizeof (result));
  bool loop_cond = true;
  while (loop_cond && fgets (route_buf, sizeof (route_buf), stdin))
  {
    char *newline = strchr (route_buf, '\n');
    if (newline == NULL)
    {
      /* input too big, throw away invalid input, show message to user */
      for (int c = getchar (); c != EOF && c != '\n'; c = getchar ())
        ;
      printf (msg_template, sizeof (result));
      memset (route_buf, 0, sizeof (route_buf));
    }
    else
    {
      int len = newline - route_buf;
      memcpy (result.data, route_buf, len);
      loop_cond = false;
    }
  } 
  return result;
}

//function to input a description
desc_t prompt_input_desc (char const *msg_template)
{
  desc_t result = DESC_T_INITIALIZER;
  char desc_buffer[sizeof (result) + 1] = BUF_INITIALIZER;
  printf (msg_template, sizeof (result));
  bool loop_cond = true;
  while (loop_cond && fgets (desc_buffer, sizeof (desc_buffer), stdin))
  {
    char *newline = strchr (desc_buffer, '\n');
    if (newline == NULL)
    {
      for (int c = getchar (); c != EOF && c != '\n'; c = getchar ())
        ;
      printf (msg_template, sizeof (result));
      memset (desc_buffer, 0, sizeof (desc_buffer));
    }
    else
    {
      int len = newline - desc_buffer;
      memcpy (result.data, desc_buffer, len);
      loop_cond = false;
    }
  }
  return result;
}

//function to input a name

name_t prompt_input_name (char const *msg_template)
{
  return prompt_input_desc (msg_template);
}

//function to print a tasks' document BST
void print_docs (tnode_t* t, int space)
{
  if (t == NULL)
  {
    return;
  }
  space += TNODE_SPACING;
  print_docs (t->r, space);
  /* printf ("\n"); */
  for (int i = TNODE_SPACING; i < space; ++i)
  {
    printf (" ");
  }
  printf ("%d\n", t->doc.id);
  print_docs (t->l, space);
}

// function to interactively edit a document in a task
void interactive_document_edit (void)
{
  task_list_t* list = &tasks;
  if (!list->head)
  {
    printf ("\nNo tasks yet\n\n");
    return;
  }
  print_list (&tasks);
  printf ("input ID of task with document, ");
  task_t* task_ref = get_task_ref (list);
  tnode_t* root = &task_ref->docs;
  if (root->doc.id == INVALID_ID)
  {
    printf ("task has no documents\n");
    return;
  }
  printf ("documents in task\n");
  show_docs (root);
  printf ("\ninput ID of document to edit, ");
  int id = INVALID_ID;
  while (id == INVALID_ID)
  {
    id = prompt_input_int ();
    if (id == INVALID_ID)
    {
      printf ("task IDs must be positive integers\nplease input a valid task ID\n");
    }
  }
  tnode_t* node = find_document (id, root);
  doc_t* d = &node->doc;
  while (d == NULL)
  {
    printf ("\nplease input an existing document's ID\n");
    while (id == INVALID_ID)
    {
      id = prompt_input_int ();
      if (id == INVALID_ID)
      {
        printf ("task IDs must be positive integers\nplease input a valid task ID\n");
      }
    }
    node = find_document (id, root);
    d = &node->doc;
  }
  *d = prompt_doc_data ();
  (*d).id = id;
  (*d).type = task_ref->type;
}

//function to delete a node in a task's documents BST

void remove_bst_node (tnode_t* mainroot, tnode_t* root, int id)
{
  if (mainroot == NULL || root == NULL || id == INVALID_ID)
  {
    return;
  }
  if (id == root->doc.id)
  {
    if (root->l == NULL && root->r == NULL)
    {
      if (root == mainroot)
      {
        memset (&root->doc, 0, sizeof(root->doc));
      }
      else
      {
        tnode_t* parent = find_parent (mainroot, root);
        if (parent->doc.id < root->doc.id)
        {
          parent->r = NULL;
        }
        else
        {
          parent->l = NULL;
        }
        free (root);
      }
    }
    else if (root->l == NULL)
    {
      tnode_t* tmp = root->r;
      memcpy (&root->doc, tmp, sizeof(*tmp));
      free (tmp);
    }
    else if (root->r == NULL)
    {
      tnode_t* tmp = root->l;
      memcpy (&root->doc, tmp, sizeof(*tmp));
      free (tmp);
    }
    else
    {
      if (root->l->r == NULL)
      {
        tnode_t* tmp = root->l;
        memcpy (&root->doc, &tmp->doc, sizeof(tmp->doc));
        root->l = tmp->l;
        free (tmp);
      }
      else
      {
        tnode_t* big_small = find_biggest (root->l);
        tnode_t* tmp = big_small;
        tnode_t* parent = find_parent(root, big_small);
        memcpy (&root->doc, &tmp->doc, sizeof(tmp->doc));
        parent->r = big_small->l;
        free (tmp);
      }
    }
  }
  else
  {
    tnode_t* subtreeroot = find_document (id, root);
    remove_bst_node (mainroot, subtreeroot, id);
  }
}

// function to remove a document in a task

void interactive_document_remove (void)
{
  task_list_t* list = &tasks;
  if (!list->head)
  {
    printf ("\nNo tasks yet\n\n");
    return;
  }
  print_list (&tasks);
  printf ("input ID of task with document, ");
  task_t* task_ref = get_task_ref (list);
  tnode_t* root = &task_ref->docs;
  if (root->doc.id == INVALID_ID)
  {
    printf ("task has no documents\n");
    return;
  }
  printf ("documents in task\n");
  show_docs (root);
  printf ("\ninput ID of document to remove, ");
  int id = INVALID_ID;
  while (id == INVALID_ID)
  {
    id = prompt_input_int ();
    if (id == INVALID_ID)
    {
      printf ("task IDs must be positive integers\nplease input a valid task ID\n");
    }
  }
  tnode_t* node = find_document (id, root);
  while (node == NULL)
  {
    printf ("\nplease input an existing document's ID\n");
    while (id == INVALID_ID)
    {
      id = prompt_input_int ();
      if (id == INVALID_ID)
      {
        printf ("task IDs must be positive integers\nplease input a valid task ID\n");
      }
    }
    node = find_document (id, root);
  }
  remove_bst_node (root, root, id);
}
